<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Here recording my growth of technology and hope you can gain something here."><meta name="keywords" content=""><meta name="author" content="George"><meta name="copyright" content="George"><title>Welcome to my blog. | A.</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">George</div><div class="author-info__description text-center">Here recording my growth of technology and hope you can gain something here.</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">84</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">18</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">19</span></a></div></div></div><nav id="nav" style="background-image: url(https://Albatross-G.github.io/img/a1.png)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">A.</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">A.</div><div id="site-sub-title">Welcome to my blog.</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2021/01/26/github%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/">github使用技巧</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-01-26</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/">环境安装</a></span><div class="content"><h1 id="初始化的一些东西"><a href="#初始化的一些东西" class="headerlink" title="初始化的一些东西"></a>初始化的一些东西</h1><p>首先主要是借鉴了<a href="https://www.cnblogs.com/smilejinge/p/3589479.html" target="_blank" rel="noopener">这篇文章</a></p>
<h2 id="关于密钥"><a href="#关于密钥" class="headerlink" title="关于密钥"></a>关于密钥</h2><p>先生成密钥</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;your_email@qq.com&quot;</span><br></pre></td></tr></table></figure>

<p>接着复制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>粘贴到github的密钥里</p>
<h2 id="关于用户名和邮箱"><a href="#关于用户名和邮箱" class="headerlink" title="关于用户名和邮箱"></a>关于用户名和邮箱</h2><p><img src="/2021/01/26/github%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/1-1.png" alt="1-1"></p>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ol>
<li><p>在合适的地方建一个目录</p>
</li>
<li><p>进入所创建的目录，然后将该目录变为Git可以管理的仓库，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入本地仓库目录，可查看本地仓库目录的状态，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure>
</li>
<li><p>远程初始一个Git仓库，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git --bare init</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加远程地址，设置GitHub的仓库地址并取名为origin【也可以取名为自定义】，命令如下：【yourRepo是你在github上建好的仓库】</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:yourName&#x2F;yourRepo.git</span><br></pre></td></tr></table></figure>

<p>上条命令中的yourName和yourRepo表示你在GitHub中的用户名和前面在GitHub中所新建的仓库的名称，添加完之后进入.git，打开config，这里会多出一个remote “origin”内容，这就是刚才添加的远程地址，也可以直接修改config来配置远程地址。</p>
</li>
</ol>
<h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><p><img src="/2021/01/26/github%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/1-2.png" alt="1-2"></p>
<blockquote>
<p>git push命令会将本地仓库中的内容推送到远程服务器上。</p>
<p>修改完代码后，使用git status可以查看文件的差别；</p>
<p>使用git add 添加要commit的文件，也可以用git add -i来智能添加文件，git add -A添加所有文件；</p>
<p>之后使用git commit提交本次修改；</p>
<p>最后使用git push上传到github。</p>
</blockquote>
<h2 id="git工作区、暂存区和版本库"><a href="#git工作区、暂存区和版本库" class="headerlink" title="git工作区、暂存区和版本库"></a>git工作区、暂存区和版本库</h2><p><a href="https://www.runoob.com/git/git-workspace-index-repo.html" target="_blank" rel="noopener">参考文章</a></p>
<img src="/2021/01/26/github%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/gitblog\1\source\_posts\github使用技巧\1-3.png" alt="1-3" style="zoom:150%;">





<h2 id="git将github上内容clone到本地仓库"><a href="#git将github上内容clone到本地仓库" class="headerlink" title="git将github上内容clone到本地仓库"></a>git将github上内容clone到本地仓库</h2><p>克隆仓库的命令格式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;repo&gt;</span><br></pre></td></tr></table></figure>

<p>如果我们需要克隆到指定的目录，可以使用以下命令格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;repo&gt; &lt;directory&gt;</span><br></pre></td></tr></table></figure>





<h2 id="基本操作汇总"><a href="#基本操作汇总" class="headerlink" title="基本操作汇总"></a>基本操作汇总</h2><p><a href="https://www.runoob.com/git/git-basic-operations.html" target="_blank" rel="noopener">参考文章</a></p>
<p><img src="/2021/01/26/github%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/1-4.jpg" alt="1-4"></p>
<h2 id="分支有关操作"><a href="#分支有关操作" class="headerlink" title="分支有关操作"></a>分支有关操作</h2><p><img src="/2021/01/26/github%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/1-4.png" alt="1-4"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git branch			&#x2F;&#x2F;查看分支</span><br><span class="line">git branch &lt;name&gt;			&#x2F;&#x2F;创建名字为name的分支</span><br><span class="line">git checkout &lt;name&gt;			&#x2F;&#x2F;切换到名字为name的分支</span><br><span class="line">git branch -d &lt;name&gt;			&#x2F;&#x2F;删除名字为name的分支</span><br><span class="line">git branch -b &lt;name&gt;			&#x2F;&#x2F;创建名字为name的新分支并且切换到该分支下</span><br></pre></td></tr></table></figure>

<p>分支的内容为创建时工作区里的内容，上图中为test1和test2。</p>
<p><img src="/2021/01/26/github%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/1-5.png" alt="1-5"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;name&gt;			&#x2F;&#x2F;将名字为name的分支融合到master上</span><br><span class="line">有冲突的话会要求你手动消除冲突。</span><br></pre></td></tr></table></figure>







<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log			&#x2F;&#x2F;查看历史</span><br></pre></td></tr></table></figure>

<p><a href="https://www.runoob.com/git/git-commit-history.html" target="_blank" rel="noopener">gitlog有关命令</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a v1.0 </span><br></pre></td></tr></table></figure>

<p><a href="https://www.runoob.com/git/git-tag.html" target="_blank" rel="noopener">gittag有关命令</a></p>
</blockquote>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/01/22/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/">环境搭建中的一些问题</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-01-22</time><div class="content"></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/01/14/%E5%AE%89%E5%85%A8%E6%96%87%E7%AB%A0%E6%B5%8F%E8%A7%88%E8%AE%B0%E5%BD%95/">安全文章浏览记录</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-01-14</time><div class="content"><h1 id="2021年"><a href="#2021年" class="headerlink" title="2021年"></a>2021年</h1><h2 id="1月"><a href="#1月" class="headerlink" title="1月"></a>1月</h2><h3 id="14号"><a href="#14号" class="headerlink" title="14号"></a>14号</h3><ol>
<li><a href="https://cloud.tencent.com/developer/article/1371906" target="_blank" rel="noopener">preg_replace漏洞</a></li>
<li><a href="https://blog.csdn.net/rfrder/article/details/109723519" target="_blank" rel="noopener">preg_replace漏洞2</a></li>
</ol>
<h3 id="19号"><a href="#19号" class="headerlink" title="19号"></a>19号</h3><ol>
<li><a href="https://xz.aliyun.com/t/6050" target="_blank" rel="noopener">ssrf me【代码审计】</a></li>
</ol>
<h3 id="21号"><a href="#21号" class="headerlink" title="21号"></a>21号</h3><ol>
<li><a href="https://blog.skullsecurity.org/2012/everything-you-need-to-know-about-hash-length-extension-attacks" target="_blank" rel="noopener">md5扩展【纯英文】</a></li>
<li><a href="https://www.freebuf.com/articles/web/69264.html" target="_blank" rel="noopener">hash长度扩展攻击</a></li>
</ol>
<h3 id="24号"><a href="#24号" class="headerlink" title="24号"></a>24号</h3><ol>
<li><a href="https://www.jianshu.com/p/e1403b7140fa" target="_blank" rel="noopener">python【BeautifulSoup库】</a></li>
</ol>
<h3 id="25号"><a href="#25号" class="headerlink" title="25号"></a>25号</h3><ol>
<li><a href="https://blog.csdn.net/c406495762/article/details/72331737" target="_blank" rel="noopener">Selenium与python爬虫</a></li>
</ol>
<h3 id="26号"><a href="#26号" class="headerlink" title="26号"></a>26号</h3><ol>
<li><a href="https://www.cnblogs.com/smilejinge/p/3589479.html" target="_blank" rel="noopener">github简单使用</a></li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">模电期末复习</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-01-08</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">期末复习</a></span><div class="content"><h1 id="第一章：直流电路"><a href="#第一章：直流电路" class="headerlink" title="第一章：直流电路"></a>第一章：直流电路</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/1-1.png" alt="1-1"></p>
<h2 id="等效电路"><a href="#等效电路" class="headerlink" title="等效电路"></a>等效电路</h2><p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/1-3.png" alt="1-3"></p>
<h2 id="节点分析法"><a href="#节点分析法" class="headerlink" title="节点分析法"></a>节点分析法</h2><p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/1-2.png" alt="1-2"></p>
<h1 id="第四章：集成运算放大器"><a href="#第四章：集成运算放大器" class="headerlink" title="第四章：集成运算放大器"></a>第四章：集成运算放大器</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/4-11.png" alt="4-11"></p>
<p>电压输入时，Ri越大越好；</p>
<p>电压输出时，Ro越小越好。</p>
<p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/4-1.png" alt="4-1"></p>
<p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/4-2.png" alt="4-2"></p>
<h2 id="几种经典的放大器"><a href="#几种经典的放大器" class="headerlink" title="几种经典的放大器"></a>几种经典的放大器</h2><h3 id="反向比例电路"><a href="#反向比例电路" class="headerlink" title="反向比例电路"></a>反向比例电路</h3><p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/4-3.png" alt="4-3"></p>
<p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/4-4.png" alt="4-4"></p>
<h3 id="同相比例电路"><a href="#同相比例电路" class="headerlink" title="同相比例电路"></a>同相比例电路</h3><p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/4-5.png" alt="4-5"></p>
<p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/4-6.png" alt="4-6"></p>
<h4 id="同向比例的特例：电压跟随器【输入-输出】"><a href="#同向比例的特例：电压跟随器【输入-输出】" class="headerlink" title="同向比例的特例：电压跟随器【输入=输出】"></a>同向比例的特例：电压跟随器【输入=输出】</h4><p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/4-7.png" alt="4-7"></p>
<h3 id="反向加法放大电路"><a href="#反向加法放大电路" class="headerlink" title="反向加法放大电路"></a>反向加法放大电路</h3><p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/4-8.png" alt="4-8"></p>
<h3 id="同向加法放大电路【略难】"><a href="#同向加法放大电路【略难】" class="headerlink" title="同向加法放大电路【略难】"></a>同向加法放大电路【略难】</h3><p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/4-9.png" alt="4-9"></p>
<h3 id="单运放减法运算电路"><a href="#单运放减法运算电路" class="headerlink" title="单运放减法运算电路"></a>单运放减法运算电路</h3><p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/4-10.png" alt="4-10"></p>
<h1 id="第五章：半导体二极管及直流稳态"><a href="#第五章：半导体二极管及直流稳态" class="headerlink" title="第五章：半导体二极管及直流稳态"></a>第五章：半导体二极管及直流稳态</h1><p>二极管类型：</p>
<ul>
<li>点接触型【PN结面积小，允许小电流通过】</li>
<li>面接触型【允许大电流通过】</li>
<li>硅平面型</li>
</ul>
<p>代表符号：</p>
<p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/5-1.png" alt="5-1"></p>
<h2 id="半导体的伏安特性曲线"><a href="#半导体的伏安特性曲线" class="headerlink" title="半导体的伏安特性曲线"></a>半导体的伏安特性曲线</h2><p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/5-2.png" alt="5-2"></p>
<p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/5-3.png" alt="5-3"></p>
<h2 id="二极管的几种模型"><a href="#二极管的几种模型" class="headerlink" title="二极管的几种模型"></a>二极管的几种模型</h2><h3 id="简化模型"><a href="#简化模型" class="headerlink" title="简化模型"></a>简化模型</h3><p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/5-4.png" alt="5-4"></p>
<h3 id="恒压降模型"><a href="#恒压降模型" class="headerlink" title="恒压降模型"></a>恒压降模型</h3><p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/5-5.png" alt="5-5"></p>
<h3 id="折线模型"><a href="#折线模型" class="headerlink" title="折线模型"></a>折线模型</h3><p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/5-6.png" alt="5-6"></p>
<h3 id="交流小信号模型"><a href="#交流小信号模型" class="headerlink" title="交流小信号模型"></a>交流小信号模型</h3><p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/5-7.png" alt="5-7"></p>
<p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/5-8.png" alt="5-8"></p>
<h2 id="常考题型"><a href="#常考题型" class="headerlink" title="常考题型"></a>常考题型</h2><p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/5-9.png" alt="5-9"></p>
<h1 id="第六章：晶体三极管及其放大电路"><a href="#第六章：晶体三极管及其放大电路" class="headerlink" title="第六章：晶体三极管及其放大电路"></a>第六章：晶体三极管及其放大电路</h1><p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/6-1.png" alt="6-1"></p>
<p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/6-2.png" alt="6-2"></p>
<p>所以，我们可以知道</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IE&gt;IC&gt;IB</span><br></pre></td></tr></table></figure>

<p>由此引出了第一种常考题型：</p>
<h2 id="常考题型1"><a href="#常考题型1" class="headerlink" title="常考题型1"></a>常考题型1</h2><p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/6-3.png" alt="6-3"></p>
<blockquote>
<p>由<code>IE&gt;IC&gt;IB</code>可以知道<code>一号---IC、二号---IB、三号---IE</code>，而IE是指向里面的，所以是PNP型。</p>
<p>β=IC/IB=1.5/0.03=50            //β要取绝对值</p>
</blockquote>
<p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/6-4.png" alt="6-4"></p>
<p>由此引出第二种常考题型：</p>
<h2 id="常考题型2"><a href="#常考题型2" class="headerlink" title="常考题型2"></a>常考题型2</h2><p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/6-5.png" alt="6-5"></p>
<p>如图1：</p>
<blockquote>
<p>处于中间值的是5.6V，所以管脚B对应5.6V</p>
<p>和管脚B相差0.6<del>0.7或者0.2</del>0.3的是管脚E，所以管脚E是5V，同时判断得到这是硅管</p>
<p>剩下的是管脚C，所以VC&gt;VB&gt;VE，所以是NPN型</p>
</blockquote>
<h2 id="判断在截止区、放大区还是饱和区"><a href="#判断在截止区、放大区还是饱和区" class="headerlink" title="判断在截止区、放大区还是饱和区"></a>判断在截止区、放大区还是饱和区</h2><p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/6-6.png" alt="6-6"></p>
<p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/6-8.png" alt="6-7"></p>
<p>在放大区时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IC&#x3D;βIB，IE&#x3D;IC+IB≈IC</span><br></pre></td></tr></table></figure>



<h2 id="常考题型3"><a href="#常考题型3" class="headerlink" title="常考题型3"></a>常考题型3</h2><p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/6-9.png" alt="6-9"></p>
<p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/6-10.png" alt="6-10"></p>
<h2 id="基本共射极放大电路的组成"><a href="#基本共射极放大电路的组成" class="headerlink" title="基本共射极放大电路的组成"></a>基本共射极放大电路的组成</h2><h3 id="符号记法"><a href="#符号记法" class="headerlink" title="符号记法"></a>符号记法</h3><p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/6-11.png" alt="6-11"></p>
<p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/6-12.png" alt="6-12"></p>
<p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/6-13.png" alt="6-13"></p>
<h3 id="直流通路"><a href="#直流通路" class="headerlink" title="直流通路"></a>直流通路</h3><p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/D:%5Cgitblog%5C1%5Csource_posts%5C%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%5C6-14.png" alt="6-14"></p>
<p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/D:%5Cgitblog%5C1%5Csource_posts%5C%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0%5C6-15.png" alt="6-15"></p>
<h3 id="动态电路"><a href="#动态电路" class="headerlink" title="动态电路"></a>动态电路</h3><p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/6-16.png" alt="6-16"></p>
<p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/6-17.png" alt="6-17"></p>
<p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/6-18.png" alt="6-18"></p>
<h2 id="失真"><a href="#失真" class="headerlink" title="失真"></a>失真</h2><p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/6-19.png" alt="6-19"></p>
<p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/6-20.png" alt="6-20"></p>
<h1 id="第九章：负反馈放大"><a href="#第九章：负反馈放大" class="headerlink" title="第九章：负反馈放大"></a>第九章：负反馈放大</h1><h2 id="四种典型电路"><a href="#四种典型电路" class="headerlink" title="四种典型电路"></a>四种典型电路</h2><h3 id="电压串联负反馈"><a href="#电压串联负反馈" class="headerlink" title="电压串联负反馈"></a>电压串联负反馈</h3><p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/9-1.png" alt="9-1"></p>
<p>电压控制电压源</p>
<p>负反馈优点：稳定输出电压</p>
<h3 id="电压并联负反馈"><a href="#电压并联负反馈" class="headerlink" title="电压并联负反馈"></a>电压并联负反馈</h3><p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/9-2.png" alt="9-2"></p>
<p>电流控制电压源</p>
<h3 id="电流串联负反馈"><a href="#电流串联负反馈" class="headerlink" title="电流串联负反馈"></a>电流串联负反馈</h3><p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/9-3.png" alt="9-3"></p>
<p>电压控制电流源</p>
<h3 id="电流并联负反馈"><a href="#电流并联负反馈" class="headerlink" title="电流并联负反馈"></a>电流并联负反馈</h3><p><img src="/2021/01/08/%E6%A8%A1%E7%94%B5%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/9-4.png" alt="9-4"></p>
<p>电流控制电流源</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/01/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">数据库期末复习</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-01-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">期末复习</a></span><div class="content"><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="数据库的三级模式和二级映射"><a href="#数据库的三级模式和二级映射" class="headerlink" title="数据库的三级模式和二级映射"></a>数据库的三级模式和二级映射</h2><h3 id="数据库的三级模式"><a href="#数据库的三级模式" class="headerlink" title="数据库的三级模式"></a>数据库的三级模式</h3><ol>
<li>用户级–&gt; 外模式(反映了数据库系统的用户观)   【数据库中的外模式对应<strong>视图</strong>】</li>
<li>概念级–&gt; 概念模式/模式（反映了数据库系统的整体观)   【<strong>模式</strong>是数据库全体数据的全局逻辑结构。】【数据库三级模式结构中用于描述表结构的是<strong>模式</strong>】</li>
<li>物理级 –&gt; 内模式（反映了数据库系统的存储观）【索引属于内模式】</li>
</ol>
<h3 id="数据库的两级映射"><a href="#数据库的两级映射" class="headerlink" title="数据库的两级映射"></a>数据库的两级映射</h3><ul>
<li>模式/内模式的映像：实现概念模式到内模式之间的相互转换。</li>
<li>外模式/模式的映像：实现外模式到概念模式之间的相互转换。</li>
</ul>
<p><img src="/2021/01/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/1-1.png" alt="1-1"></p>
<h2 id="数据独立性"><a href="#数据独立性" class="headerlink" title="数据独立性"></a>数据独立性</h2><p><strong>数据库的数据的独立性</strong>是指数据与程序独立，将数据的定义从程序中分离出来，由DBMS（数据库管理系统）负责数据的存储，从而简化应用程序，大大减少应用程序编制的工作量。</p>
<p>数据的独立性是由DBMS的二级映像功能来保证的。<strong>数据的独立性</strong>包括数据的<strong>物理独立性</strong>和数据的<strong>逻辑独立性</strong>。</p>
<blockquote>
<p>什么是数据的物理独立性？</p>
<p>答：数据的物理独立性是指当数据库的<strong>内模式</strong>（存储模式）发生改变时，数据的的逻辑结构不变。由于应用程序处理的只是数据的逻辑结构，这样物理独立性可以保证，当数据的物理结构改变了，应用程序不用改变。但是，为了保证应用程序能够正确执行，需要修改概念模式/内模式之间的映像。</p>
<p>什么是数据的逻辑独立性？</p>
<p>答：数据的逻辑独立性是指用户的应用程序与数据库结构是相互独立的。数据的逻辑结构发生变化后，用户程序也可以不修改。但是，为了保证应用程序能够正确执行，需要修改外模式/概念模式之间的映像。</p>
</blockquote>
<p>一句话总结一下：</p>
<p><strong>通俗来讲就是如果改变了某个模式，只需要修改上一层的映像。即改变内模式，只需要修改模式/内模式映像（物理独立性），改变概念模式（逻辑结构），只需要修改外模式/模式映像（逻辑独立性）</strong></p>
<h2 id="概念模型和逻辑模型"><a href="#概念模型和逻辑模型" class="headerlink" title="概念模型和逻辑模型"></a>概念模型和逻辑模型</h2><p>对现实世界抽象层次的不同,数据模型分为有<strong>概念模型</strong>和<strong>结构模型</strong></p>
<p><strong>概念模型</strong>是一种独立于硬件和软件的模型,完全不涉及信息在系统中的表现,只是用来描述某个特定组织所关心的信息结构。这种模型是从用户的观点对数据建模,必须充分反映用户的需求,并得到用户的确认才可定下来。<strong>它是现实世界的第一层抽象</strong>,是用户和数据库设计人员之间进行交流的工具,其典型代表是<strong>ER模型</strong>。   【实体、属性以及实体间的联系】</p>
<p><strong>结构模型</strong>用于描述数据库的逻辑结构,与DBMS有关。这种模型是从计算机的观点对数据建模。<strong>它是现实世界的第二层抽象</strong>,是数据库设计人员和应用程序员之间进行交流的工具。其典型代表是层次、网状、关系和面向对象模型。</p>
<h2 id="常见缩写"><a href="#常见缩写" class="headerlink" title="常见缩写"></a>常见缩写</h2><p>数据库（DB）：长期存储在计算机内的有组织、可共享的数据集合。</p>
<p>数据库管理员（DBA）</p>
<blockquote>
<p>例题</p>
<p>DBA负责全面地管理和控制数据库系统。具体职责不包括：（A）</p>
<p>A.实现数据库访问接口的JAVA代码的编写和维护。</p>
<p>B.决定数据库的信息内容和结构，以及数据库的存储结构和存取策略。</p>
<p>C.定义数据的安全性要求和完整性约束条件。</p>
<p>D.监督和控制数据库的使用和运行，改进和重组数据系统。</p>
</blockquote>
<p>数据库管理系统（DBMS）</p>
<p>数据库系统（DBS）：一般由数据库、数据库管理系统（及其开发工具）、应用系统、数据库管理员构成。一般在不引起混淆的情况下常常把数据库系统简称为数据库。</p>
<h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="常见的数据模型："><a href="#常见的数据模型：" class="headerlink" title="常见的数据模型："></a>常见的数据模型：</h2><p>常用的数据模型主要有层次模型、网状模型和关系模型。</p>
<p>（1）层次模型：用树形结构表示实体类型与实体间的联系。</p>
<p>特点：</p>
<p>每棵树仅有一个无双亲节点，成为根。</p>
<p>树中除根外，所有节点有且仅有一个双亲。</p>
<p>（2）网状模型：用有向图表示实体类型及实体间的联系。</p>
<p>（3） <strong>关系模型</strong> ：以二维表来描述数据。</p>
<h3 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h3><p>特点：</p>
<ul>
<li>A.关系模型与非关系模型不同，它是建立在严格的数学概念的基础上的。</li>
<li>B.关系模型的概念单一，无论实体还是实体之间的联系都用关系表示，操作的对象和操作的结果都是关系，所以其数据结构简单、清晰，用户易懂易用。</li>
<li>C.关系模型的存取路径对用户透明，从而具有更高的数据独立性.更好的安全保密性，也简化了程序员的工作和数据库开发建立的工作。</li>
</ul>
<h2 id="三类完整性约束"><a href="#三类完整性约束" class="headerlink" title="三类完整性约束"></a>三类完整性约束</h2><h3 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h3><p>实体完整性是通过主码（PRIMARY KEY）的定义来实现的。一旦某个属性或属性组被定义为主码，该主码的每个属性就<strong>不能为空值</strong>，并且在表中<strong>不能出现主码值完全相同</strong>的两个记录。</p>
<h3 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h3><p>如果键值更改了，那么在整个数据库中，对该键值的所有引用要进行一致的更改。</p>
<h3 id="用户自定义完整性"><a href="#用户自定义完整性" class="headerlink" title="用户自定义完整性"></a>用户自定义完整性</h3><p>类似于check对数据的约束。</p>
<h2 id="数据库设计阶段"><a href="#数据库设计阶段" class="headerlink" title="数据库设计阶段"></a>数据库设计阶段</h2><p> 按照规范设计的方法，考虑到数据库及其应用系统开发的全过程，将数据库设计分为六个阶段：</p>
<h3 id="①-需求分析"><a href="#①-需求分析" class="headerlink" title="①.需求分析"></a>①.需求分析</h3><p>​    需求收集和分析，得到用数据字典描述的数据需求，用数据流图描述的处理需求</p>
<h3 id="②-概念结构设计"><a href="#②-概念结构设计" class="headerlink" title="②.概念结构设计"></a>②.概念结构设计</h3><p>​    对需求进行综合、归纳与抽象，形成一个独立于具体DBMS的概念模型（用E-R图表示）</p>
<h3 id="③-逻辑结构设计"><a href="#③-逻辑结构设计" class="headerlink" title="③.逻辑结构设计"></a>③.逻辑结构设计</h3><p>​    将概念结构转换为某个DBMS所支持的数据模型（比如 关系模型 ），并对其进行优化</p>
<h3 id="④-物理结构设计"><a href="#④-物理结构设计" class="headerlink" title="④.物理结构设计"></a>④.物理结构设计</h3><p>​    为逻辑数据模型选取一个最适合应用环境的物理结构（包括存储结构、存取方法）</p>
<h3 id="⑤-数据库实施"><a href="#⑤-数据库实施" class="headerlink" title="⑤.数据库实施"></a>⑤.数据库实施</h3><p>​    运用DBMS提供的数据语言（比如 SQL）及其宿主语言（例如 C、C++），根据逻辑设计和物理设计的结果建立数据库，编制与调试应用程序，组织数据入库，并进行试运行</p>
<h3 id="⑥-数据库运行与维护"><a href="#⑥-数据库运行与维护" class="headerlink" title="⑥.数据库运行与维护"></a>⑥.数据库运行与维护</h3><p>​    数据库应用系统经过试运行后即可投入正式运行。在数据库系统运行过程中必须不断地对其进行评价、调整与修改</p>
<h2 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h2><p>第一范式：在一个关系中消除重复字段，且各字段都是最小的逻辑存储单位。【即每个数据段只有一个元素】</p>
<p>第二范式：若关系模型属于第一范式，则关系中每一个非主键关系字段，都完全依赖于主关键字段，不能只部分依赖主关键字的一部分。【所有属性都只依赖于主属性，即通过主属性可以确定到这一行数据】</p>
<p>第三范式：若关系模型属于第一范式，且关系中所有非主关键字段都只依赖与主关键字段，第三范式要求去掉传递依赖。【即任意两个非主属性之间都不存在依赖关系】</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="1-关系-Relation"><a href="#1-关系-Relation" class="headerlink" title="1)关系(Relation)"></a>1)关系(Relation)</h3><p>一个关系对应通常说的一张表</p>
<h3 id="2-元组-Tuple"><a href="#2-元组-Tuple" class="headerlink" title="2)元组(Tuple)"></a>2)元组(Tuple)</h3><p>表中的一行即为一个元组</p>
<h3 id="3-属性-Attribute"><a href="#3-属性-Attribute" class="headerlink" title="3)属性(Attribute)"></a>3)属性(Attribute)</h3><p>表中的一列即为一个属性，给每一个属性起一个名称，即属性名</p>
<h3 id="4-码（键）"><a href="#4-码（键）" class="headerlink" title="4)码（键）"></a>4)码（键）</h3><p><strong>码是数据系统中的基本概念。所谓码就是能唯一标识实体的属性，他是整个实体集的性质，而不是单个实体的性质。它包括超码，候选码，主码。</strong></p>
<ul>
<li><strong>超码</strong>是一个或多个属性的集合，这些属性可以让我们在一个实体集中唯一地标识一个实体。</li>
<li><strong>候选码</strong>:关系(表)中的某个属性组,它可以唯一确定一个元组。</li>
<li>若一个关系(表)中有多个候选码,则选定其中一个为主码。</li>
<li><strong>全码</strong>:关系的所有属性都包含在候选码中。</li>
<li><strong>主属性</strong>:包含在任何一个候选码中的属性</li>
<li><strong>非主属性</strong> 不包含在任何码中的属性</li>
<li><strong>主码</strong>: 主键就是候选键里面的一个，是人为规定的，例如学生表中，我们通常会让“学号”做主键，教师表中让“教师编号”做主键。</li>
<li><strong>外码</strong>： 外键比较简单，学生表中的外键就是“教师编号”。外键主要是用来描述两个表的关系。</li>
<li><strong>域(Domain)</strong>:属性的取值范围。</li>
<li><strong>分量</strong>:元组中的一个属性值。</li>
<li><strong>形式化定义</strong><br>R(D 1 ,D 2 ,…D n )<br>R:关系名<br>n:关系的目或度(Degree)<br><strong>例:</strong><br>关系名(属性1,属性2,…,属性n)<br>学生(学号,姓名,年龄,性别,系,年级)<br><strong>候补码和超码</strong>：<br>候选码是从超码中选出的，自然地候选码也是一个或多个属性的集合。<br>因为超码的范围太广，很多是我们并不感兴趣即无用处的。所以候选码是最小超码，它们的任意真子集都不能成为超码。<br><strong>例如，如果K是超码，那么所有包含K的集合都不能是候选码；如果K，J都不是超码，那么K和J组成的集合（K，J）有可能是候选码。</strong></li>
</ul>
<h2 id="数据库的安全性、完整性、并发控制和恢复"><a href="#数据库的安全性、完整性、并发控制和恢复" class="headerlink" title="数据库的安全性、完整性、并发控制和恢复"></a>数据库的安全性、完整性、并发控制和恢复</h2><p><strong>数据的完整性</strong>包括 ：实体完整性、参照完整性和用户定义的完整性。</p>
<h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><h2 id="系统数据库"><a href="#系统数据库" class="headerlink" title="系统数据库"></a>系统数据库</h2><ol>
<li>Master</li>
<li>Model：模板</li>
<li>MSDB：</li>
<li>TempDB：临时数据库</li>
</ol>
<h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><h2 id="char、varchar、nchar、nvarchar的区别："><a href="#char、varchar、nchar、nvarchar的区别：" class="headerlink" title="char、varchar、nchar、nvarchar的区别："></a>char、varchar、nchar、nvarchar的区别：</h2><ul>
<li>char：  固定长度，存储ANSI字符，不足的补英文半角空格。</li>
<li>nchar：  固定长度，存储Unicode字符，不足的补英文半角空格</li>
<li>varchar： 可变长度，存储ANSI字符，根据数据长度自动变化。</li>
<li>nvarchar： 可变长度，存储Unicode字符，根据数据长度自动变化。</li>
</ul>
<p>n开头的存储均为两个字节，包括英文；其他的英文一个字节，汉字两个字节。</p>
<blockquote>
<p>1、如果是单字节编码，举个例子ASCII，一个字符（准确来说是英文字符）是用一个字节编码的，而按照ASCII的拓展编码（具体是哪个编码规则忘了，不过可以统称ANSI），一个汉字是用两个字符表示，所以在此编码规则下，存放一个汉字（两个字符）需要两个字节，而char(10)中的10指的是字符个数，而不是多少字节（虽然在这种编码下得到的结果一样，因为一个字符对应一个字节，但是对于双字节编码的不是这样理解的），所以char(10)可以存10个字符，两个个字符表示一个汉字，所以最多存5个汉字。</p>
<p>2、如果是双字节编码，一个字符（这里的字符不仅仅包括英文字符，还包括中文字符即汉字，以及其他的字符）是用两个字节编码的，nchar()存储的是UNICODE字符，它是采用双字节编码规则，即一个字符相当于两个字节，但是nchar(10)其实不需要考虑到字节问题，这个10指的就是字符个数，在此规则下汉字和英文字符一样的性质，所以nchar(10)就能存10个汉字。</p>
</blockquote>
<h1 id="第六章【SQL语言】"><a href="#第六章【SQL语言】" class="headerlink" title="第六章【SQL语言】"></a>第六章【SQL语言】</h1><h1 id="unique与distinct-的区别"><a href="#unique与distinct-的区别" class="headerlink" title="unique与distinct 的区别"></a>unique与distinct 的区别</h1><p>unique 和 distinct 都是去重的意思，但他们所用的语句不同</p>
<ul>
<li><p>1：unique 可以用于在创建表时或者在修改表的结构时使用</p>
<blockquote>
<p>例如：</p>
<p>create table test(sno int not null unique);</p>
<p>或者 alter table test alter unique(sname);</p>
</blockquote>
</li>
<li><p>2:distinct则是用于对select 语句使用</p>
<blockquote>
<p>例如： select distinct depart from test</p>
</blockquote>
</li>
</ul>
<h2 id="E-R图"><a href="#E-R图" class="headerlink" title="E-R图"></a>E-R图</h2><table>
<thead>
<tr>
<th>E</th>
<th>R</th>
</tr>
</thead>
<tbody><tr>
<td>实体</td>
<td>矩形</td>
</tr>
<tr>
<td>属性</td>
<td>圆形</td>
</tr>
<tr>
<td>联系</td>
<td>菱形</td>
</tr>
</tbody></table>
<h1 id="小点"><a href="#小点" class="headerlink" title="小点"></a>小点</h1><ol>
<li><p>一个数据模型至少需要描述数据的<strong>静态特征</strong>、<strong>动态特征</strong>、<strong>完整性约束</strong>三项内容。</p>
</li>
<li><p>数据模型的三要素是<strong>数据结构</strong>、<strong>数据操作</strong>和<strong>数据完整性约束</strong></p>
</li>
<li><p><strong>DB</strong>是长期存储在计算机内的有组织、可共享的数据集合。</p>
</li>
<li><p>关系数据库中的<strong>数据完整性</strong>是指<strong>数据的正确性</strong></p>
</li>
<li><p><strong>数据结构</strong>是数据模型性质的最重要的描述。在数据库系统中，人们通常依据其类型来命名数据模型。</p>
</li>
<li><p>下列哪个语句用来清除自最近的事务语句以来的所有修改？<strong>（ROLLBACK TRANSACTION）</strong></p>
</li>
<li><p><strong>二维表结构</strong>是关系数据库采用的<strong>组织层</strong>数据模型</p>
</li>
<li><p><strong>文件系统</strong>具有的数据独立性是<strong>设备独立性</strong></p>
</li>
<li><p>数据库在磁盘上的基本组织形式是<strong>文件</strong></p>
</li>
<li><p>TRUNCATE TABLE相当于无条件的DELETE FROM</p>
</li>
<li><pre><code>create table employee ( employee_id int primary key, employee_name nvarchar(50) not null, dept_no int foreign key references dept(dept_no) )
外键约束建立在从表的字段上</code></pre></li>
<li><p>有UNIQUE约束的列，其取值一定<strong>取值不重</strong>，但<strong>只允许有一个空值</strong></p>
</li>
<li><p>数据库完整性保护的约束条件主要是指</p>
</li>
<li><p><img src="/2021/01/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/2.png" alt="2"></p>
</li>
<li><p>在已有数据的表上定义CHECK约束时，默认情况下：系统在建立约束之前检查表中的数据，<strong>符合约束条件时才能建立约束</strong></p>
</li>
<li><blockquote>
<p>在ER模型中，如果有3个不同的实体型，3个M：N联系，根据ER模型转换为关系模型的规则，转换为关系的数目是（ 6  ）。</p>
<p>一个实体转换成一个关系模式，这就3个了<br>一个多对多联系转换成一个关系模式，关系的属性是联系两端实体的主键加上联系本身的属性（如果有的话），这又是3个了<br>如果是1:1或者1：n联系，本身并不转换成关系模式</p>
</blockquote>
</li>
<li><p><img src="/2021/01/01/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/4.png" alt="4"></p>
</li>
</ol>
<pre><code>![3](数据库期末复习/3.png)</code></pre><ol start="18">
<li><p>如果实体A与实体B之间是多对多联系，为描述两个实体之间的关联关系，添加了联系C来关联实体A和B，添加联系C的作用是<strong>将多对多联系转化为一对多联系</strong></p>
</li>
<li></li>
</ol>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol>
<li>1-1-55</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/01/01/JAVA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">JAVA期末复习</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-01-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">期末复习</a></span><div class="content"><h1 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h1><p><img src="/2021/01/01/JAVA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/1.png" alt="1"></p>
<h2 id="关键字：abstract"><a href="#关键字：abstract" class="headerlink" title="关键字：abstract"></a>关键字：abstract</h2><p>用来修饰<strong>抽象类</strong>与<strong>抽象类中的方法</strong>【不能修饰变量】</p>
<p><strong>抽象类需要注意的几点：</strong></p>
<ol>
<li>抽象类不能被实例化。抽象类可以包含属性；方法；构造方法，但是构造方法不能用来new实例，只能被子类调用</li>
<li>有抽象方法的类，一定是抽象类，但是抽象类可以没有抽象方法。</li>
<li>当一个类继承的父类是抽象类的话，需要我们把抽象类中的所有抽象方法全部实现，除非子类也为抽象类。</li>
<li>抽象方法不能有方法体。</li>
<li>抽象类不能用final声明，因为抽象类只有被继承才有存在的意义，final修饰的 </li>
</ol>
<p>类不可以被继承</p>
<h2 id="关键字：final"><a href="#关键字：final" class="headerlink" title="关键字：final"></a>关键字：final</h2><p>用来修饰类，类属性，类方法</p>
<p><strong>注意：</strong></p>
<ol>
<li><p>被final修饰的<strong>类</strong>不能被继承。</p>
</li>
<li><p>final修饰的<strong>类方法</strong>不能被重写，子类只有调用final方法的权利，没有修改final方法 的权利</p>
</li>
<li><p>被final修饰的<strong>类属性</strong>只可在初始化赋值，不可被重新赋值</p>
</li>
<li><p>使用final修饰<strong>引用型变量</strong>，变量不可以指向另外的对象</p>
</li>
</ol>
<h1 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h1><p>java中的方法重载发生在<strong>同一个类里面</strong>两个或者多个方法的<strong>方法名相同</strong>但是<strong>参数不同</strong>的情况。</p>
<p>与此相对，方法覆盖是说<strong>子类重新定义了父类的方法</strong>。方法覆盖必须有<strong>相同的方法名，参数列表和返回类型</strong>。</p>
<p>覆盖者可能不会限制它所覆盖的方法的访问。</p>
<h2 id="重载（Overloading）"><a href="#重载（Overloading）" class="headerlink" title="重载（Overloading）"></a>重载（Overloading）</h2><ul>
<li>（1）方法重载是让类以统一的方法处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数（类型）。重载Override是一个类中多态性的一种表现。</li>
<li>（2）java的方法重载，就是在类中可以创建多个方法，他们具有相同的名字，但具有不同参数和不同的定义。调用方法时通过传递给他们不同的参数个数和参数类型来决定具体使用那个方法，这就是多态性。</li>
<li>（3）重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不同。无法以返回类型来作为重载函数的区分标准。</li>
</ul>
<h2 id="重写（Overriding）"><a href="#重写（Overriding）" class="headerlink" title="重写（Overriding）"></a>重写（Overriding）</h2><ul>
<li>（1）父类与子类的多态性，对父类的函数进行重新定义。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写。在java中，子类可继承父类的方法，则不需要重新编写相同的方法。但有时子类并不想原封不动继承父类的方法，而是想做一定的修改，这就采用方法重写。方法重写又称方法覆盖。</li>
<li>（2）若子类中的方法与父类的中的某一方法具有相同的方法名、返回类型和参数表，则新方法覆盖原有的方法。如需要父类的原有方法，可以使用super关键字，该关键字引用房钱类的父类。</li>
<li>（3）子类函数访问权限大于父类。</li>
</ul>
<h1 id="小点"><a href="#小点" class="headerlink" title="小点"></a>小点</h1><ol>
<li><p>在使用interface声明一个接口时，只可以使用public/default修饰符修饰该接口。</p>
</li>
<li><p>String实例一旦创建完毕，就不能再修改其内容</p>
</li>
<li><p>不允许使用final来修饰abstract方法</p>
</li>
<li><p>接口中的方法默认都是public、abstract类型的。【非静态】</p>
<blockquote>
<p><strong>接口Interface</strong><br>\1. 接口中的<strong>成员变量</strong>默认都是public、static、final类型的，必须被显式初始化<br>\2. 接口中的<strong>方法</strong>默认都是public、abstract类型的。<br>\3. 接口中只能包含public、static、final类型的成员变量和public、abstract类型的成员方法。<br>\4. 接口没有构造方法，不能被实例化，在接口中定义构造方法是非法的。<br>\5. 一个接口不能实现另一个接口，但它可以继承多个其他接口。<br>interface C extends A, B{} // A和B都是接口<br>\6. 当类实现某个接口时，它必须实现接口中所有的抽象方法，否则这个类必须被定义为抽象类。<br>\7. 接口中没有方法体<br>访问控制修饰符<br>四种访问级别：public、protected、默认、private<br>private只能在同一个类中访问<br>默认，只能在同一个类，同一个包中访问<br>protected，可以在统一各类，同一个包，子类(子类可以不在同一个包中)访问<br>public，不限制访问<br>类可用修饰符： abstract、public、final<br>构造方法：public、protected、private<br>局部变量：仅仅final<br>abstract修饰符<br>\1. 抽象类中可以没有抽象方法，但包含了抽象方法的类必须被定义为抽象类。<br>\2. 没有抽象构造方法，没有抽象静态方法。 static 和 abstract不能连用<br>\3. 抽象类中可以有非抽象的构造方法，创建子类的实例时可能会调用这些构造方法。<br>\4. 抽象类及抽象方法不能被final修饰符修饰。final和abstract 不能连用，同样private和abstract不能连用。<br>\5. 抽象类不能被实例化。因为抽象类可能含有没有方法体的抽象方法<br>final修饰符<br>final具有;不可改变的;含义，它可以修饰非抽象类，非抽象成员方法和变量<br>\1. 用final修饰的类不能被继承，没有子类。<br>\2. 用final修饰的方法不能被子类的方法覆盖。<br>\3. 用final修饰的变量表示常量，只能被赋一次值，必须被显式初始化。<br>\4. private修饰的方法默认为是final方法，因而不能被子类的方法覆盖。<br>static修饰符<br>\1. 静态变量在内存中只有一个拷贝，在类的所有实例中共享。<br>\2. 在静态方法中不能直接访问实例方法和实例变量。<br>\3. 在静态方法中不能使用this和super关键字。<br>\4. 静态方法不能被abstract修饰<br>\5. 静态方法和静态变量都可以通过类名直接被访问。<br>\6. 当类被加载时，静态代码块只被执行一次。类中不同的静态代码块按它们在类中出现的顺序被依次执行<br>public static void main(String args[]) {} 程序入口方法，可以被final修饰。<br>super关键字<br>\1. 在类的构造方法中，通过super语句调用这个类的父类的构造方法。<br>在构造方法中，super语句必须作为构造方法的第一条语句。<br>\2. 在子类中访问父类的被屏蔽的方法和属性<br>\3. 只能在构造方法或实例方法内使用super关键字。 super关键字与类的特定实例相关<br>方法覆盖（方法重写）<br>\1. 方法的参数签名和返回值类型必须相同，访问控制修饰符可以不同，但是子类方法不能缩小父类方法的访问权限。<br>\2. 子类方法抛出的异常必须和父类方法抛出的异常相同，或者是父类方法抛出的异常类的子类。<br>\3. 父类的静态方法是不能被子类覆盖为非静态方法。<br>父类的非静态方法不能被子类覆盖为静态方法。<br>\4. 子类可以定义与父类的静态方法同名的静态方法，以便在子类中隐藏父类的静态方法。区别：运行时，JVM把静态方法和所属的类绑定，而把实例方法和所属的实例绑定。<br>\5. 父类的私有方法不能被覆盖<br>\6. 父类的非抽象方法可以被覆盖为抽象方法<br>方法重（chong）载<br>\1. 在一个类中不允许两个方法名相同，并且参数签名也完全相同的方法。<br>\2. 类的同一种功能，可能有多种实现，到底采用哪种实现方式，取决于调用者给定的参数。<br>\3. 对于类的方法（包括从父类中继承的方法），如果有两个方法的方法名相同，但参数不一致，那么可以说，一个方法是另一个方法的重载方法。<br>多态<br>\1. 对于一个引用类型的变量，Java编译器按照它声明的类型来处理。<br>Base base = new Sub();<br>base.subMethod(); // 编译出错，Base基类，Sub子类，编译器认为base是Base类型的引用变量，Base类没有subMethod()方法。这样子，就必须使用强制转换。(Sub)(base).subMethod();<br>\2. 对于一个引用类型的变量，运行时JVM按照它实际引用的对象来处理。<br>Base base = new Base();<br>Sub sub = (Sub)base; // 编译通过，但是运行时抛出ClassCastException<br>在运行时，子类的引用类型变量可以转换为父类的引用类型，而相反的过程却不可以。<br>假定可以，即上边两行代码运行正常，那么sub.subMethod(); 执行时，JVM将找不到subMethod。sub实际引用的是Base类的实例。<br>\3. 在运行时环境中，通过引用类型变量来访问所引用对象的方法和属性时，JVM采用以下的绑定规则。<br>①实例方法与引用变量实际引用的对象的方法绑定，即动态绑定。<br>②静态方法与引用变量所声明的类型的方法绑定，即静态绑定。 编译阶段即绑定完成。<br>③成员变量(静态变量和实例变量) 与引用类型所声明的类型的成员变量绑定。静态绑定。</p>
</blockquote>
</li>
</ol>
<ol start="5">
<li><p>抽象类不一定有抽象方法。</p>
</li>
<li><p>为AB类的一个无形式参数无返回值的方法method书写方法头，使得使用类名AB作为前缀就可以调用它，该方法头的形式为（static ）。</p>
</li>
<li><p>Java允许创建不规则数组，即Java多维数组中各行的列数可以不同。【相当于一维数组的一维数组】</p>
</li>
<li><pre><code class="java"><span class="comment">//两种初始化方法</span>
<span class="keyword">int</span>[][] myArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>][];   <span class="comment">//二维数组初始化时，5这个地方必须有值</span>
<span class="keyword">int</span>[][] myArray = &lt;!--￼<span class="number">1</span>--&gt;;

<span class="comment">//其中第一种：</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoDimensionArray</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{
        <span class="keyword">int</span>[][] myArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>][];
        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;myArray.length;i++){
            myArray[i] = <span class="keyword">new</span> <span class="keyword">int</span>[myArray.length-i];
            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;myArray.length-i;j++){
                myArray[i][j]=i*<span class="number">10</span>+j;
            }
        }

        System.out.println(myArray[<span class="number">1</span>][<span class="number">2</span>]);
    }
}
&lt;!--￼<span class="number">0</span>--&gt;
Son mygs = <span class="keyword">new</span> grandSon();</code></pre>
</li>
</ol>
<p>此时，Son和grandSon名字不一样，grandSon是Son的子类，相当于grandSon无参构造之后，付给了Son的对象，相当于放弃了Son里的属性，即名字还是Son里的名字。</p>
<h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>The array size is fixed after it is created.   （T）</p>
<p>The array size is fixed after an array reference variable is declared.   （F）</p>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><img src="/2021/01/01/JAVA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/2.png" alt="2"></p>
<p><img src="/2021/01/01/JAVA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/3.png" alt="3"></p>
<p><img src="/2021/01/01/JAVA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/4.png" alt="4"></p>
<p><img src="/2021/01/01/JAVA%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/5.png" alt="5"></p>
<p>这题选A</p>
<p>异常处理</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2021/01/01/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">离散数学期末复习</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-01-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">期末复习</a></span><div class="content"><h1 id="代数"><a href="#代数" class="headerlink" title="代数"></a>代数</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>本章中定义<code>A=&lt;S，。，▲，k&gt;</code>，其中。是S上的二元运算，▲是S上的一元运算。</p>
<h2 id="代数结构"><a href="#代数结构" class="headerlink" title="代数结构"></a>代数结构</h2><p>代数通常由以下三部分组成：</p>
<ol>
<li>一个集合，叫做代数的<strong>载体</strong></li>
<li>定义在载体上的<strong>运算</strong></li>
<li>载体的特异元素，叫做<strong>代数常数</strong></li>
</ol>
<blockquote>
<p>例：</p>
<ol>
<li>载体是整数集合I</li>
<li>定义在I上的运算是加法</li>
<li>常数是0</li>
</ol>
<p>可构成代数系统：&lt;I,+,0&gt;</p>
</blockquote>
<h2 id="子代数"><a href="#子代数" class="headerlink" title="子代数"></a>子代数</h2><p>设<code>A=&lt;S，。，▲，k&gt;</code>是一个代数，如果</p>
<ol>
<li>S‘ 属于S</li>
<li>S’对于S上的运算。，▲封闭</li>
<li>k∈S’</li>
</ol>
<p>则称<code>A&#39;=&lt;S&#39;，。，▲，k&gt;</code>是A的子代数</p>
<h2 id="同态"><a href="#同态" class="headerlink" title="同态"></a>同态</h2><h3 id="同构"><a href="#同构" class="headerlink" title="同构"></a>同构</h3><p>代数<code>A=&lt;S，*，▲，k&gt;</code>和<code>A&#39;=&lt;S&#39;，*&#39;，▲&#39;，k&#39;&gt;</code>是<strong>同构</strong>的，如果存在一<strong>双射函数h</strong>，使</p>
<ol>
<li>h： S-&gt;S’</li>
<li>h(a * b)=h(a) *’ h(b)</li>
<li>h(▲a)=▲’h(a)</li>
<li>h(k)=k’</li>
</ol>
<p>这里a，b是S上的任意元素</p>
<blockquote>
<p>设f是从集合A到集合B的映射，若f(A)=B，即B中任一元素b都是A中某元素的像，则称f为A到B上的<strong>满射</strong>；</p>
<p>若对A中任意两个不同元素a1不等于a2，它们的像f1不等于f2，则称f为A到B的<strong>单射</strong>；</p>
<p>若映射f既是单射，又是满射，则称映射f为A到B的“双射”(或“一一映射)”)。 函数为双射当且仅当每个可能的像有且仅有一个变量与之对应。</p>
</blockquote>
<h3 id="同态-1"><a href="#同态-1" class="headerlink" title="同态"></a>同态</h3><p>代数<code>A=&lt;S，*，▲，k&gt;</code>和<code>A&#39;=&lt;S&#39;，*&#39;，▲&#39;，k&#39;&gt;</code>是<strong>同态</strong>的，如果存在一函数<strong>h</strong>，使</p>
<ol>
<li>h： S-&gt;S’</li>
<li>h(a * b)=h(a) *’ h(b)</li>
<li>h(▲a)=▲’h(a)</li>
<li>h(k)=k’</li>
</ol>
<p>这里a，b是S上的任意元素</p>
<p>其中：</p>
<ol>
<li>如果h是单射的，则h是单一同态</li>
<li>如果h是满射的，则h是满同态</li>
<li>如果A=A’，则h是自同态</li>
</ol>
<h2 id="半群和独异点"><a href="#半群和独异点" class="headerlink" title="半群和独异点"></a>半群和独异点</h2><img src="/2021/01/01/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/6-1.png" alt="6-1" style="zoom:50%;">

<p>生成元：设<code>&lt;S，*，e&gt;</code>是独异点，如果存在一个元素g，对于每一个元素a∈S，都有一个相应的h∈N能满足a=g^h，则称此独异点为<strong>循环独异点</strong>。并称元素g为此循环独异点的<strong>生成元</strong>。</p>
<h2 id="群"><a href="#群" class="headerlink" title="群"></a>群</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>代数系统满足：</p>
<ol>
<li>封闭，可结合</li>
<li>有幺元</li>
<li>有逆元</li>
</ol>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol>
<li><p>如果&lt;G,*&gt;是一个群，则对于任何a，b∈G，<code>(a * b)^-1 = b^-1 * a^-1</code></p>
</li>
<li><table>
<thead>
<tr>
<th>阶数</th>
<th>群的个数</th>
<th>是否为阿贝尔群</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>4</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>6</td>
<td>2</td>
<td>0</td>
</tr>
</tbody></table>
</li>
<li><p>如果&lt;G,*&gt;是一个群，且a∈G，如果存在正整数n使得a^n=e，则称元素的阶是有限的。如果不存在这样的n，则称元素的阶是无限的。</p>
</li>
<li><p>群中任一元素和它的逆元具有相同的阶</p>
</li>
</ol>
<h3 id="置换群和循环群"><a href="#置换群和循环群" class="headerlink" title="置换群和循环群"></a>置换群和循环群</h3><p>置换群：n阶置换群有n！个</p>
<p>置换群的乘法：</p>
<p><img src="/2021/01/01/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/6-2.png" alt="6-2"></p>
<p>注：这个为左合成，右合成过程相反。</p>
<h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>给定n个元素组成的集合A，A上的置换所构成的群称为<strong>n次置换群</strong>；A上所有置换构成的群称为<strong>n次对称群</strong>。</p>
<h3 id="子群和群同态"><a href="#子群和群同态" class="headerlink" title="子群和群同态"></a>子群和群同态</h3><h4 id="子群"><a href="#子群" class="headerlink" title="子群"></a>子群</h4><ol>
<li>若群&lt;G,*&gt;为有限群，对于任意元素a，b∈S，有a * b∈S，那么&lt;S, *&gt;是&lt;G, * &gt;的子群。</li>
<li>若群&lt;G,*&gt;不确定为有限群，对于任意元素a，b∈S，有a * b∈S 和 若a∈S，那么a^-1∈S，那么&lt;S, *&gt;是&lt;G, * &gt;的子群。</li>
</ol>
<h4 id="群同态"><a href="#群同态" class="headerlink" title="群同态"></a>群同态</h4><p>只要满足h(a*b) = h(a) *’ h(b)</p>
<h3 id="陪集和拉格朗日定理"><a href="#陪集和拉格朗日定理" class="headerlink" title="陪集和拉格朗日定理"></a>陪集和拉格朗日定理</h3><p><img src="/2021/01/01/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/6-3.png" alt="6-3"></p>
<p>拉格朗日定理：子群的阶数是群阶数的因子</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/12/30/%E6%B1%87%E7%BC%96%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">汇编期末复习</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-12-30</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">期末复习</a></span><div class="content"><h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><p><img src="/2020/12/30/%E6%B1%87%E7%BC%96%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/1.png" alt="1"></p>
<p><img src="/2020/12/30/%E6%B1%87%E7%BC%96%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/2.png" alt="2"></p>
<p>间接寻址</p>
<p><img src="/2020/12/30/%E6%B1%87%E7%BC%96%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/3.png" alt="3"></p>
<p><img src="/2020/12/30/%E6%B1%87%E7%BC%96%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/4.png" alt="4"></p>
<p><img src="/2020/12/30/%E6%B1%87%E7%BC%96%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/5.png" alt="5"></p>
<p><img src="/2020/12/30/%E6%B1%87%E7%BC%96%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/6.png" alt="6"></p>
<p>loop</p>
<p><img src="/2020/12/30/%E6%B1%87%E7%BC%96%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/7.png" alt="7"></p>
<p>例子</p>
<p><img src="/2020/12/30/%E6%B1%87%E7%BC%96%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/8.png" alt="8"></p>
<p><img src="/2020/12/30/%E6%B1%87%E7%BC%96%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/9.png" alt="9"></p>
<h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><h2 id="pop-push"><a href="#pop-push" class="headerlink" title="pop/push"></a>pop/push</h2><p>堆栈是预先分配好的一段内存地址，其中<strong>栈底的地址最大</strong>。</p>
<p><img src="/2020/12/30/%E6%B1%87%E7%BC%96%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/6-1.png" alt="6-1"></p>
<p><img src="/2020/12/30/%E6%B1%87%E7%BC%96%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/6-2.png" alt="6-2"></p>
<blockquote>
<p>在vs2017调试的时候，如果要看字符串的值，需要输入字符串的首地址。</p>
<p>比如查看名为Name的字符串，可以快速监视  <code>&amp;Name</code></p>
</blockquote>
<h2 id="call-ret"><a href="#call-ret" class="headerlink" title="call/ret"></a>call/ret</h2><p><img src="/2020/12/30/%E6%B1%87%E7%BC%96%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/6-4.png" alt="6-4"></p>
<h2 id="标号"><a href="#标号" class="headerlink" title="标号"></a>标号</h2><p><img src="/2020/12/30/%E6%B1%87%E7%BC%96%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/6-5.png" alt="6-5"></p>
<h2 id="寄存器实现参数传递"><a href="#寄存器实现参数传递" class="headerlink" title="寄存器实现参数传递"></a>寄存器实现参数传递</h2><p><img src="/2020/12/30/%E6%B1%87%E7%BC%96%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/6-6.png" alt="6-6"></p>
<h3 id="Uses的使用【在某一过程里简化压栈和出栈】"><a href="#Uses的使用【在某一过程里简化压栈和出栈】" class="headerlink" title="Uses的使用【在某一过程里简化压栈和出栈】"></a>Uses的使用【在某一过程里简化压栈和出栈】</h3><p><img src="/2020/12/30/%E6%B1%87%E7%BC%96%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/6-7.png" alt="6-7"></p>
<h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><h2 id="标志位"><a href="#标志位" class="headerlink" title="标志位"></a>标志位</h2><p><img src="/2020/12/30/%E6%B1%87%E7%BC%96%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/7-1.png" alt="7-1"></p>
<p><img src="/2020/12/30/%E6%B1%87%E7%BC%96%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/7-3.png" alt="7-3"></p>
<h2 id="AND"><a href="#AND" class="headerlink" title="AND"></a>AND</h2><p><img src="/2020/12/30/%E6%B1%87%E7%BC%96%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/7-2.png" alt="7-2"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">支持的格式：</span><br><span class="line">AND reg , reg</span><br><span class="line">AND reg , mem</span><br><span class="line">AND reg , imm</span><br><span class="line">AND mem , reg</span><br><span class="line">AND mem , imm</span><br></pre></td></tr></table></figure>





<h2 id="条件跳转指令"><a href="#条件跳转指令" class="headerlink" title="条件跳转指令"></a>条件跳转指令</h2><h3 id="测试指令【cmp、test】"><a href="#测试指令【cmp、test】" class="headerlink" title="测试指令【cmp、test】"></a>测试指令【cmp、test】</h3><h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4><p>TEST a , b：也是比较a与b，本质是a&amp;b，不修改a和b，如果a&amp;b=0，则zf标志位置1。</p>
<h4 id="cmp"><a href="#cmp" class="headerlink" title="cmp"></a>cmp</h4><p>CMP a , b：比较a与b，本质是a-b，不修改a和b，修改部分标志寄存器，配合跳转指令使用</p>
<h3 id="基于特定的标志位"><a href="#基于特定的标志位" class="headerlink" title="基于特定的标志位"></a>基于特定的标志位</h3><p><img src="/2020/12/30/%E6%B1%87%E7%BC%96%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/7-4.png" alt="7-4"></p>
<h3 id="基于判断两操作数是否相等"><a href="#基于判断两操作数是否相等" class="headerlink" title="基于判断两操作数是否相等"></a>基于判断两操作数是否相等</h3><p><img src="/2020/12/30/%E6%B1%87%E7%BC%96%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/7-5.png" alt="7-5"></p>
<h3 id="基于无符号操作数的结果比较的"><a href="#基于无符号操作数的结果比较的" class="headerlink" title="基于无符号操作数的结果比较的"></a>基于无符号操作数的结果比较的</h3><p><img src="/2020/12/30/%E6%B1%87%E7%BC%96%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/7-6.png" alt="7-6"></p>
<h3 id="基于有符号操作数的结果比较的"><a href="#基于有符号操作数的结果比较的" class="headerlink" title="基于有符号操作数的结果比较的"></a>基于有符号操作数的结果比较的</h3><p><img src="/2020/12/30/%E6%B1%87%E7%BC%96%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/7-7.png" alt="7-7"></p>
<h2 id="条件循环指令"><a href="#条件循环指令" class="headerlink" title="条件循环指令"></a>条件循环指令</h2><p>指令格式：LOOPZ 目的地址</p>
<p>目的地址跟当前指令的距离在-128~127之间</p>
<p>LOOPE与LOOPZ等价</p>
<p>循环条件：<strong>ecx不等于0</strong>并且<strong>ZF标志位为1</strong>时跳转，即与LOOP指令不同的地方就是要同时判别ZF标志位</p>
<p>LOOPNZ与LOOPZ类似，只是循环条件是ecx不等于0并且ZF标志位为0时跳转（书中的说明有误）</p>
<h2 id="决策伪指令"><a href="#决策伪指令" class="headerlink" title="决策伪指令"></a>决策伪指令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.IF  condition1</span><br><span class="line">     statements</span><br><span class="line">[.ELSEIF  condition2</span><br><span class="line">    statements ]</span><br><span class="line">[.ELSE</span><br><span class="line">    statements ]</span><br><span class="line">.ENDIF</span><br><span class="line"></span><br><span class="line">.IF  (DL &lt; 0 ) || (DL &gt; 79)</span><br><span class="line">.IF (DL &gt; &#x3D;0 ) &amp;&amp; (DL &lt;&#x3D; 79)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.REPEAT</span><br><span class="line">    statements</span><br><span class="line">.UNTIL  condition</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.WHILE </span><br><span class="line">    statements</span><br><span class="line">.ENDW</span><br></pre></td></tr></table></figure>







<h1 id="第七章【整数算术指令】"><a href="#第七章【整数算术指令】" class="headerlink" title="第七章【整数算术指令】"></a>第七章【整数算术指令】</h1><h2 id="移位"><a href="#移位" class="headerlink" title="移位"></a>移位</h2><p>逻辑移位和算数移位，左移无区别，主要是右移存在区别。</p>
<h3 id="左移【SHL、SAL】"><a href="#左移【SHL、SAL】" class="headerlink" title="左移【SHL、SAL】"></a>左移【SHL、SAL】</h3><p>左移是一种特殊的快速乘法，左移n位，相当于乘以2^n</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHL 目的操作数，移位位数</span><br></pre></td></tr></table></figure>

<p><img src="/2020/12/30/%E6%B1%87%E7%BC%96%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/8-1.png" alt="8-1"></p>
<h3 id="右移【SHR、SAR】"><a href="#右移【SHR、SAR】" class="headerlink" title="右移【SHR、SAR】"></a>右移【SHR、SAR】</h3><h4 id="逻辑右移【SHR】："><a href="#逻辑右移【SHR】：" class="headerlink" title="逻辑右移【SHR】："></a>逻辑右移【SHR】：</h4><p>功能：将目的操作数逻辑右移，左边移出的位添0，最低位被移出，复制到CF位中</p>
<p>SHR可以实现无符号数的快速除法</p>
<p><img src="/2020/12/30/%E6%B1%87%E7%BC%96%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/8-2.png" alt="8-2"></p>
<h4 id="算数右移【SAR】："><a href="#算数右移【SAR】：" class="headerlink" title="算数右移【SAR】："></a>算数右移【SAR】：</h4><p>在右移的过程中，最高位保持不变。</p>
<p>SAR可以实现有符号数的快速除法<img src="/2020/12/30/%E6%B1%87%E7%BC%96%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/8-3.png" alt="8-3"></p>
<h2 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h2><p><img src="/2020/12/30/%E6%B1%87%E7%BC%96%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/8-4.png" alt="8-4"></p>
<p>其中RCL和RCR是带进位循环左移和右移，即将CF位移到另一边起始位置，再将最后一位移到CF位。</p>
<p>而ROL和ROR是将最后一位移到CF和另一边第一位。</p>
<h2 id="移位和OF位"><a href="#移位和OF位" class="headerlink" title="移位和OF位"></a>移位和OF位</h2><p>在这些移位指令中，当<strong>移的位是1位</strong>时，当数的<strong>符号位发生改变</strong>，就会将溢出位OF置位1，否则清0。</p>
<p>如果移的是多位，则OF位无定义。</p>
<h2 id="SHLD-SHRD"><a href="#SHLD-SHRD" class="headerlink" title="SHLD/SHRD"></a>SHLD/SHRD</h2><p>SHLD 目的操作数，源操作数，移位位数</p>
<p>功能：将目的操作数移位，</p>
<p>左移时，用源操作数的高位填充目的操作数的低位；</p>
<p>右移时，用源操作数的低位填充目的操作数的高位。</p>
<p>源操作数自身值不改变。<img src="/2020/12/30/%E6%B1%87%E7%BC%96%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/8-5.png" alt="8-5"></p>
<h2 id="乘除运算"><a href="#乘除运算" class="headerlink" title="乘除运算"></a>乘除运算</h2><h3 id="无符号乘MUL"><a href="#无符号乘MUL" class="headerlink" title="无符号乘MUL"></a>无符号乘MUL</h3><p>格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MUL r&#x2F;m8</span><br><span class="line">MUL r&#x2F;m16</span><br><span class="line">MUL r&#x2F;m32</span><br></pre></td></tr></table></figure>

<p>指令中只有一个操作数，另一个操作数是隐含的</p>
<ul>
<li>当操作数8位时，表示这个8位数与AL相乘，结果放在AX中</li>
<li>当操作数是16位时，表示这个16位数与AX相乘，结果放在DX和AX中，DX中放高16位，AX中放低16位</li>
<li>当操作数是32位时，表示这个32位数与EAX相乘，结果放在EDX和EAX中，EDX中放高32位，EAX中放低32位</li>
</ul>
<p>当结果的高半部分为非0时，CF和OF置位，否则清0</p>
<h3 id="有符号乘法IMUL"><a href="#有符号乘法IMUL" class="headerlink" title="有符号乘法IMUL"></a>有符号乘法IMUL</h3><p>如果结果的高一半不是低一半的符号扩展，OF，CF置位</p>
<h4 id="双操作数"><a href="#双操作数" class="headerlink" title="双操作数"></a>双操作数</h4><p>功能：两个操作数相乘，结果存到第一个操作数中</p>
<p>如果第一个操作数存不下结果，OF、CF置位。</p>
<h4 id="三操作数"><a href="#三操作数" class="headerlink" title="三操作数"></a>三操作数</h4><p>功能：第二、三两个操作数相乘，结果存到第一个操作数中</p>
<p>如果第一个操作数存不下结果，OF、CF置位。</p>
<h3 id="无符号除法指令DIV"><a href="#无符号除法指令DIV" class="headerlink" title="无符号除法指令DIV"></a>无符号除法指令DIV</h3><p>实现整除运算，结果包括两项，一项为商，一项为余数。</p>
<p>格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DIV r&#x2F;m8  AX &#x2F; op8 &#x3D; AL(商) …AH(余数)</span><br><span class="line">DIV r&#x2F;m16 DX:AX&#x2F;op16 &#x3D; AX…DX</span><br><span class="line">DIV r&#x2F;m32 EDX:EAX&#x2F;op32&#x3D;EAX…EDX</span><br></pre></td></tr></table></figure>



<h3 id="有符号整数除法IDIV"><a href="#有符号整数除法IDIV" class="headerlink" title="有符号整数除法IDIV"></a>有符号整数除法IDIV</h3><p>有符号除法和无符号除法的用法基本相似。但要注意的隐含参数在进行除法操作前往往要进行符号扩展</p>
<p>符号扩展指令</p>
<p>共有三条符号扩展指令，其操作数在指令中不给出，均为隐含的寄存器</p>
<ul>
<li>CBW  将AL符号扩展到AX</li>
<li>CWD  将AX符号扩展到DX:AX</li>
<li>CDQ  将EAX符号扩展到EDX:EAX</li>
</ul>
<h2 id="扩展加法和减法"><a href="#扩展加法和减法" class="headerlink" title="扩展加法和减法"></a>扩展加法和减法</h2><ul>
<li>ADC  带进位加</li>
<li>SBB 带借位减</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/12/22/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/">逆向工程核心原理</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-12-22</time><div class="content"><h1 id="小端序和大端序"><a href="#小端序和大端序" class="headerlink" title="小端序和大端序"></a>小端序和大端序</h1><p><img src="/2020/12/22/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1-1.jpg" alt="1-1"></p>
<p>大端序【更直观】：数据的低位存储在地址的高位。</p>
<p>小端序【符合人类思维】：数据的低位存储在地址的低位。【Intel X86 CPU】</p>
<blockquote>
<p>注：对于char[]字符串，字符数组在内存中是连续的，所以无论大端序还是小端序，存储顺序都是相同的。</p>
</blockquote>
<p>用以上数据做一个测试，拖进ollydbg：</p>
<p><img src="/2020/12/22/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/1-2.png" alt="1-2"></p>
<p>可以发现这里使用的是小端序。</p>
<h1 id="IA-32寄存器【p36】"><a href="#IA-32寄存器【p36】" class="headerlink" title="IA-32寄存器【p36】"></a>IA-32寄存器【p36】</h1><h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><p>EAX：【针对操作数和结果数据】累加器</p>
<blockquote>
<p>EAX(0-31)：32位</p>
<p>AX(0-15)：16位</p>
<p>AH(8-15)：8位</p>
<p>AL(0-7)：8位</p>
</blockquote>
<p>EBX：【DS段的数据指针】基址寄存器</p>
<p>ECX：【字符串和循环操作】计数器</p>
<p>EDX：【I/O指针】数据寄存器</p>
<p>EBP：扩展基址寄存器</p>
<p>ESI：源变址寄存器</p>
<p>EDI：目的变址寄存器</p>
<p>ESP：栈指针寄存器</p>
<h2 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h2><p>CS：代码段寄存器</p>
<p>SS：栈段寄存器</p>
<p>DS：数据段寄存器</p>
<p>ES：附加（数据）段寄存器</p>
<p>FS：数据段寄存器</p>
<p>GS：数据段寄存器</p>
<h2 id="程序状态与控制寄存器"><a href="#程序状态与控制寄存器" class="headerlink" title="程序状态与控制寄存器"></a>程序状态与控制寄存器</h2><h3 id="EFLAGS：标志寄存器"><a href="#EFLAGS：标志寄存器" class="headerlink" title="EFLAGS：标志寄存器"></a>EFLAGS：标志寄存器</h3><p>ZF：零标志【运算结果为0，该位为1】</p>
<p>OF：溢出标志【有符号整数溢出时为1/MSB（Most SIgnificant Bit 最高有效位）改变时为1】</p>
<p>CF：进位标志【无符号整数溢出时为1】</p>
<blockquote>
<p>PF（parity flag）：奇偶标志位。这个位的判断需要我们将结果转为二进制来看，如果结果的低8位中有偶数个1，就将PF的值置1；如果是奇数个1，就置0。要注意的是一定是结果的低8位。</p>
<p>AF（auxiliary flag）：辅助进位标志位。这个位用的不多，所以书上也没有讲，我就简单的查了一下资料。这个位表示加减法做到一半时有没有形成进位/借位，如果有则AF=1。这么说谁都听不懂，所以我们举个例子来说下。例如 MOV AL,00001110 MOV BL,00001000 ADD AL,BL 最后结果为AL=00010110这就是低四位向高四位进位。反之在减法中第三位不够减向第四位借位(注意数位是从第0位开始数的)叫低四位向高四位借位!像前面的AL中前四位为高四位,后四位为低四位。例如,当两个字节相加时,如果从低4位向高4位有进位时,则AF=1。</p>
<p>ZF（zero flag）：零标志位。这个位就很简单了，判断结果是不是0。如果结果为0，就置1；不为0，就置0。</p>
<p>SF（sign flag）：符号标志位。既然是符号标志位，就是对有符号数据来说的。如果结果为负，就置1；结果为正，就置0。</p>
<p>TF（timer overblow flag）：定时器溢出标志。这个位主要是用来在debug中进行-t指令时使用的。当cpu在执行完一条指令后，如果检测到TF位的值为1，则产生单步中断，引发中断过程。通过这个位，我们就可以在debug中对程序进行单步跟踪。</p>
<p>IF（interrupt flag）：中断允许标志位。当IF=1时，cpu在执行完当前指令后响应中断，引发中断过程；当IF=0时，则不响应可屏蔽中断。</p>
<p>DF（direction flag）：<strong>方向标志位</strong>。在串处理指令中，控制每次操作后，si（指向原始偏移地址）、di（指向目标偏移地址）的增减。当DF=0时，每次操作后，si、di递增；DF=1时，每次操作后，si、di递减。我们可以使用cld指令将DF的值置为0，使用std指令将DF的值置为1。DF需要与rep、movsb等指令配合使用。</p>
<p>OF（overflow flag）：溢出标志位。这个位是用来判断有没有溢出的。注意溢出这个概念只对于有符号数据而言，就如同进位只对于无符号数据而言。当OF=0时，说明没有溢出；当OF=1时，说明溢出了。</p>
</blockquote>
<h2 id="指令寄存器"><a href="#指令寄存器" class="headerlink" title="指令寄存器"></a>指令寄存器</h2><p>EIP【Instruction Pointer】：CPU每执行完一条指令，就通过EIP寄存器读取并执行下一条命令。</p>
<h1 id="对一个简单程序的栈帧分析"><a href="#对一个简单程序的栈帧分析" class="headerlink" title="对一个简单程序的栈帧分析"></a>对一个简单程序的栈帧分析</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> x = a, y = b;</span><br><span class="line">    <span class="keyword">return</span> (x + y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, add(a, b));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在栈中，EBP作为栈底，ESP作为栈顶，EIP为指令指针。</p>
<p>刚开始的寄存器和栈是这样的：</p>
<p><img src="/2020/12/22/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/2-1.png" alt="2-1"></p>
<p><img src="/2020/12/22/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/2-2.png" alt="2-2"></p>
<p>1.从入口main函数进去，先配置好栈底和栈顶指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push EBP</span><br><span class="line">mov EBP,ESP</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此时，可以在栈窗口这样设置相对地址</p>
<p><img src="/2020/12/22/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/2-3.png" alt="2-3"></p>
</blockquote>
<table>
<thead>
<tr>
<th>绝对地址</th>
<th>相对地址</th>
<th>内容</th>
<th>指针</th>
</tr>
</thead>
<tbody><tr>
<td>0019FF28</td>
<td>EBP</td>
<td>0019FF70【执行main函数前EBP的地址】</td>
<td>EBP，ESP</td>
</tr>
</tbody></table>
<p>2.将栈顶向地址小的地方移动8个字节，来给main函数里的a，b变量分配空间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUB ESP,8</span><br></pre></td></tr></table></figure>

<p>然后赋值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long a &#x3D; 1, b &#x3D; 2;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV DWORD PTR SS:[EBP-4],1			&#x2F;&#x2F;a</span><br><span class="line">MOV DWORD PTR SS:[EBP-8],2			&#x2F;&#x2F;b</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>绝对地址</th>
<th>相对地址</th>
<th>内容</th>
<th>指针</th>
</tr>
</thead>
<tbody><tr>
<td>0019FF20</td>
<td>EBP-8</td>
<td>2</td>
<td>ESP</td>
</tr>
<tr>
<td>0019FF24</td>
<td>EBP-4</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>0019FF28</td>
<td>EBP</td>
<td>0019FF70【执行main函数前EBP的地址】</td>
<td>EBP</td>
</tr>
</tbody></table>
<p>3.调用add(a,b)函数，首先要传递参数a和b，这里是使用了EAX和ECX寄存器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOV EAX,DWORD PTR SS:[EBP-8]</span><br><span class="line">PUSH EAX                                 ; Arg2 &#x3D;&gt; 2</span><br><span class="line">MOV ECX,DWORD PTR SS:[EBP-4]             </span><br><span class="line">PUSH ECX                                 ; Arg1 &#x3D;&gt; 1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ps：这里先压入了b，再压入a,遵循从右向左压入函数的规则</p>
</blockquote>
<table>
<thead>
<tr>
<th>绝对地址</th>
<th>相对地址</th>
<th>内容</th>
<th>指针</th>
</tr>
</thead>
<tbody><tr>
<td>0019FF18</td>
<td>EBP-10</td>
<td>1</td>
<td>ESP</td>
</tr>
<tr>
<td>0019FF1C</td>
<td>EBP-C</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>0019FF20</td>
<td>EBP-8</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>0019FF24</td>
<td>EBP-4</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>0019FF28</td>
<td>EBP</td>
<td>0019FF70【执行main函数前EBP的地址】</td>
<td>EBP</td>
</tr>
</tbody></table>
<p>4.用CALL调用的add函数，调用的同时会把返回地址压入栈中，返回地址指的是CALL语句的下一条语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0040103C    CALL 00401000</span><br><span class="line">00401041    ADD ESP,8			&#x2F;&#x2F;call的下一句【非调用内容】</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>绝对地址</th>
<th>相对地址</th>
<th>内容</th>
<th>指针</th>
</tr>
</thead>
<tbody><tr>
<td>0019FF14</td>
<td>EBP-14</td>
<td>00401041【call线性关系上的下一条语句】</td>
<td>ESP</td>
</tr>
<tr>
<td>0019FF18</td>
<td>EBP-10</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>0019FF1C</td>
<td>EBP-C</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>0019FF20</td>
<td>EBP-8</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>0019FF24</td>
<td>EBP-4</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>0019FF28</td>
<td>EBP</td>
<td>0019FF70【执行main函数前EBP的地址】</td>
<td>EBP</td>
</tr>
</tbody></table>
<p>5.将执行main函数时EBP值压入栈，并新生成执行add函数时的栈帧</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUSH EBP</span><br><span class="line">MOV EBP,ESP</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>绝对地址</th>
<th>相对地址</th>
<th>内容</th>
<th>指针</th>
</tr>
</thead>
<tbody><tr>
<td>0019FF10</td>
<td>EBP</td>
<td>0019FF28【执行main函数时，执行add函数前EBP的地址】</td>
<td>EBP，ESP</td>
</tr>
<tr>
<td>0019FF14</td>
<td>EBP+4</td>
<td>00401041【call线性关系上的下一条语句】</td>
<td></td>
</tr>
<tr>
<td>0019FF18</td>
<td>EBP+8</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>0019FF1C</td>
<td>EBP+C</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>0019FF20</td>
<td>EBP+10</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>0019FF24</td>
<td>EBP+14</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>0019FF28</td>
<td>EBP+18</td>
<td>0019FF70【执行main函数前EBP的地址】</td>
<td></td>
</tr>
</tbody></table>
<p>6.先分配8个字节给两个long类型变量x和y，再将参数a，b的值分别赋给它们。【因为push参数时是从右往左，那么调用时先调用靠近栈顶的元素代表从左往右调用】</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">long x&#x3D;a,y&#x3D;b;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00401003  SUB ESP,8</span><br><span class="line">00401006  MOV EAX,DWORD PTR SS:[EBP+8]</span><br><span class="line">00401009  MOV DWORD PTR SS:[EBP-8],EAX</span><br><span class="line">0040100C  MOV ECX,DWORD PTR SS:[EBP+0C]</span><br><span class="line">0040100F  MOV DWORD PTR SS:[EBP-4],ECX</span><br><span class="line">&#x2F;&#x2F;EAX&#x3D;1，ECX&#x3D;2</span><br><span class="line">&#x2F;&#x2F;赋值顺序似乎是按照传参的顺序，在栈中的顺序赋值和参数上下相同【EBP-8，EBP-4和EBP+8，EBP+0C】</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>绝对地址</th>
<th>相对地址</th>
<th align="left">内容</th>
<th>指针</th>
</tr>
</thead>
<tbody><tr>
<td>0019FF08</td>
<td>EBP-8</td>
<td align="left">1</td>
<td>ESP</td>
</tr>
<tr>
<td>0019FF0C</td>
<td>EBP-4</td>
<td align="left">2</td>
<td></td>
</tr>
<tr>
<td>0019FF10</td>
<td>EBP</td>
<td align="left">0019FF28【执行main函数时，执行add函数前EBP的地址】</td>
<td>EBP</td>
</tr>
<tr>
<td>0019FF14</td>
<td>EBP+4</td>
<td align="left">00401041【call线性关系上的下一条语句】</td>
<td></td>
</tr>
<tr>
<td>0019FF18</td>
<td>EBP+8</td>
<td align="left">1</td>
<td></td>
</tr>
<tr>
<td>0019FF1C</td>
<td>EBP+C</td>
<td align="left">2</td>
<td></td>
</tr>
<tr>
<td>0019FF20</td>
<td>EBP+10</td>
<td align="left">2</td>
<td></td>
</tr>
<tr>
<td>0019FF24</td>
<td>EBP+14</td>
<td align="left">1</td>
<td></td>
</tr>
<tr>
<td>0019FF28</td>
<td>EBP+18</td>
<td align="left">0019FF70【执行main函数前EBP的地址】</td>
<td></td>
</tr>
</tbody></table>
<p>6.计算x+y</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">00401012  MOV EAX,DWORD PTR SS:[EBP-8]		&#x2F;&#x2F;先调用栈顶的</span><br><span class="line">00401015  ADD EAX,DWORD PTR SS:[EBP-4]</span><br><span class="line">&#x2F;&#x2F;EAX&#x3D;x+y&#x3D;1+2&#x3D;3</span><br></pre></td></tr></table></figure>



<p>7.将ESP指向EBP的地址，即从这时开始，局部变量x和y将不再有效</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00401018  MOV ESP,EBP</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>绝对地址</th>
<th>相对地址</th>
<th align="left">内容</th>
<th>指针</th>
</tr>
</thead>
<tbody><tr>
<td>0019FF08</td>
<td>EBP-8</td>
<td align="left">1</td>
<td></td>
</tr>
<tr>
<td>0019FF0C</td>
<td>EBP-4</td>
<td align="left">2</td>
<td></td>
</tr>
<tr>
<td>0019FF10</td>
<td>EBP</td>
<td align="left">0019FF28【执行main函数时，执行add函数前EBP的地址】</td>
<td>EBP，ESP</td>
</tr>
<tr>
<td>0019FF14</td>
<td>EBP+4</td>
<td align="left">00401041【call线性关系上的下一条语句】</td>
<td></td>
</tr>
<tr>
<td>0019FF18</td>
<td>EBP+8</td>
<td align="left">1</td>
<td></td>
</tr>
<tr>
<td>0019FF1C</td>
<td>EBP+C</td>
<td align="left">2</td>
<td></td>
</tr>
<tr>
<td>0019FF20</td>
<td>EBP+10</td>
<td align="left">2</td>
<td></td>
</tr>
<tr>
<td>0019FF24</td>
<td>EBP+14</td>
<td align="left">1</td>
<td></td>
</tr>
<tr>
<td>0019FF28</td>
<td>EBP+18</td>
<td align="left">0019FF70【执行main函数前EBP的地址】</td>
<td></td>
</tr>
</tbody></table>
<p>8.弹出栈顶元素【main函数的EBP地址】并且赋值给EBP，此时就完全删除了栈帧</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POP EBP</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>绝对地址</th>
<th>相对地址</th>
<th align="left">内容</th>
<th>指针</th>
</tr>
</thead>
<tbody><tr>
<td>0019FF08</td>
<td>EBP-8</td>
<td align="left">1</td>
<td></td>
</tr>
<tr>
<td>0019FF0C</td>
<td>EBP-4</td>
<td align="left">2</td>
<td></td>
</tr>
<tr>
<td>0019FF10</td>
<td>EBP</td>
<td align="left">0019FF28【执行main函数时，执行add函数前EBP的地址】</td>
<td></td>
</tr>
<tr>
<td>0019FF14</td>
<td>EBP+4</td>
<td align="left">00401041【call线性关系上的下一条语句】</td>
<td>ESP</td>
</tr>
<tr>
<td>0019FF18</td>
<td>EBP+8</td>
<td align="left">1</td>
<td></td>
</tr>
<tr>
<td>0019FF1C</td>
<td>EBP+C</td>
<td align="left">2</td>
<td></td>
</tr>
<tr>
<td>0019FF20</td>
<td>EBP+10</td>
<td align="left">2</td>
<td></td>
</tr>
<tr>
<td>0019FF24</td>
<td>EBP+14</td>
<td align="left">1</td>
<td></td>
</tr>
<tr>
<td>0019FF28</td>
<td>EBP+18</td>
<td align="left">0019FF70【执行main函数前EBP的地址】</td>
<td>EBP</td>
</tr>
</tbody></table>
<p>9.RETN相当于弹出栈顶的地址，并JMP过去</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RETN</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>绝对地址</th>
<th>相对地址</th>
<th align="left">内容</th>
<th>指针</th>
</tr>
</thead>
<tbody><tr>
<td>0019FF08</td>
<td>EBP-8</td>
<td align="left">1</td>
<td></td>
</tr>
<tr>
<td>0019FF0C</td>
<td>EBP-4</td>
<td align="left">2</td>
<td></td>
</tr>
<tr>
<td>0019FF10</td>
<td>EBP</td>
<td align="left">0019FF28【执行main函数时，执行add函数前EBP的地址】</td>
<td></td>
</tr>
<tr>
<td>0019FF14</td>
<td>EBP+4</td>
<td align="left">00401041【call线性关系上的下一条语句】</td>
<td></td>
</tr>
<tr>
<td>0019FF18</td>
<td>EBP+8</td>
<td align="left">1</td>
<td>ESP</td>
</tr>
<tr>
<td>0019FF1C</td>
<td>EBP+C</td>
<td align="left">2</td>
<td></td>
</tr>
<tr>
<td>0019FF20</td>
<td>EBP+10</td>
<td align="left">2</td>
<td></td>
</tr>
<tr>
<td>0019FF24</td>
<td>EBP+14</td>
<td align="left">1</td>
<td></td>
</tr>
<tr>
<td>0019FF28</td>
<td>EBP+18</td>
<td align="left">0019FF70【执行main函数前EBP的地址】</td>
<td>EBP</td>
</tr>
</tbody></table>
<blockquote>
<p>此时EIP就是00401041</p>
</blockquote>
<p>10.由于add函数已经调用结束，也就不需要参数a和b了，所以将它们清理掉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD ESP，8</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>绝对地址</th>
<th>相对地址</th>
<th align="left">内容</th>
<th>指针</th>
</tr>
</thead>
<tbody><tr>
<td>0019FF08</td>
<td>EBP-8</td>
<td align="left">1</td>
<td></td>
</tr>
<tr>
<td>0019FF0C</td>
<td>EBP-4</td>
<td align="left">2</td>
<td></td>
</tr>
<tr>
<td>0019FF10</td>
<td>EBP</td>
<td align="left">0019FF28【执行main函数时，执行add函数前EBP的地址】</td>
<td></td>
</tr>
<tr>
<td>0019FF14</td>
<td>EBP+4</td>
<td align="left">00401041【call线性关系上的下一条语句】</td>
<td></td>
</tr>
<tr>
<td>0019FF18</td>
<td>EBP+8</td>
<td align="left">1</td>
<td></td>
</tr>
<tr>
<td>0019FF1C</td>
<td>EBP+C</td>
<td align="left">2</td>
<td></td>
</tr>
<tr>
<td>0019FF20</td>
<td>EBP+10</td>
<td align="left">2</td>
<td>ESP</td>
</tr>
<tr>
<td>0019FF24</td>
<td>EBP+14</td>
<td align="left">1</td>
<td></td>
</tr>
<tr>
<td>0019FF28</td>
<td>EBP+18</td>
<td align="left">0019FF70【执行main函数前EBP的地址】</td>
<td>EBP</td>
</tr>
</tbody></table>
<p>11.调用printf()函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">00401044  PUSH EAX</span><br><span class="line">00401045  PUSH OFFSET 0040B384                     ; ASCII &quot;%d</span><br><span class="line">0040104A  CALL 00401067</span><br><span class="line">0040104F  ADD ESP,8</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;%d\n&quot;,add(a,b));</span><br></pre></td></tr></table></figure>

<p>printf有两个参数，一个是”%d\n”，另一个是add(a,b)的返回值。</p>
<p>所以从右往左依次压入这些参数，随后调用。</p>
<p>调用完成后，按规矩清理这两个参数。</p>
<p>最后栈变成这样：</p>
<table>
<thead>
<tr>
<th>绝对地址</th>
<th>相对地址</th>
<th align="left">内容</th>
<th>指针</th>
</tr>
</thead>
<tbody><tr>
<td>0019FF08</td>
<td>EBP-8</td>
<td align="left">1</td>
<td></td>
</tr>
<tr>
<td>0019FF0C</td>
<td>EBP-4</td>
<td align="left">2</td>
<td></td>
</tr>
<tr>
<td>0019FF10</td>
<td>EBP</td>
<td align="left">0019FF28【执行main函数时，执行add函数前EBP的地址】</td>
<td></td>
</tr>
<tr>
<td>0019FF14</td>
<td>EBP+4</td>
<td align="left">00401041【call线性关系上的下一条语句】</td>
<td></td>
</tr>
<tr>
<td>0019FF18</td>
<td>EBP+8</td>
<td align="left">0040B384</td>
<td></td>
</tr>
<tr>
<td>0019FF1C</td>
<td>EBP+C</td>
<td align="left">3</td>
<td></td>
</tr>
<tr>
<td>0019FF20</td>
<td>EBP+10</td>
<td align="left">2</td>
<td>ESP</td>
</tr>
<tr>
<td>0019FF24</td>
<td>EBP+14</td>
<td align="left">1</td>
<td></td>
</tr>
<tr>
<td>0019FF28</td>
<td>EBP+18</td>
<td align="left">0019FF70【执行main函数前EBP的地址】</td>
<td>EBP</td>
</tr>
</tbody></table>
<p>12.设置返回值0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return 0;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XOR EAX，EAX</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么不用<code>MOV EAX，0</code>？</p>
<p>XOR EAX，EAX执行速度快一些</p>
</blockquote>
<p>13.删除main函数的栈帧</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV ESP，EBP</span><br><span class="line">POP EBP</span><br></pre></td></tr></table></figure>

<p>之后EBP又指向执行main函数之前EBP地址，一切恢复如初。</p>
<h1 id="三种函数调用方式"><a href="#三种函数调用方式" class="headerlink" title="三种函数调用方式"></a>三种函数调用方式</h1><h2 id="cdecl"><a href="#cdecl" class="headerlink" title="cdecl"></a>cdecl</h2><ol>
<li><p>函数的参数以逆序压入栈【从右向左】</p>
</li>
<li><p>调用函数RETN后，在调用者函数中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD ESP，n</span><br></pre></td></tr></table></figure>

<p>来清理栈</p>
</li>
</ol>
<h2 id="stdcall"><a href="#stdcall" class="headerlink" title="stdcall"></a>stdcall</h2><ol>
<li><p>清理栈的任务交给了被调用者函数，在函数返回时</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RETN 8		&#x2F;&#x2F;RETN+POP 8字节</span><br></pre></td></tr></table></figure>
</li>
<li><p>这种调用方法<strong>兼容性</strong>更好</p>
</li>
</ol>
<h2 id="fastcall"><a href="#fastcall" class="headerlink" title="fastcall"></a>fastcall</h2><p>正如名字所描述的fast，fastcall通常使用寄存器而非栈内存传递参数，因为访问寄存器通常会快很多。</p>
<p>但当需要备份、程序复杂时，也不一定就快。</p>
<h1 id="操作技巧"><a href="#操作技巧" class="headerlink" title="操作技巧"></a>操作技巧</h1><h2 id="Ollydbg"><a href="#Ollydbg" class="headerlink" title="Ollydbg"></a>Ollydbg</h2><h3 id="保存打完补丁的文件"><a href="#保存打完补丁的文件" class="headerlink" title="保存打完补丁的文件"></a>保存打完补丁的文件</h3><ol>
<li><img src="/2020/12/22/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/0-1.png" alt="0-1"></li>
<li>在新跳出的页面<img src="/2020/12/22/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/0-2.png" alt="0-2"></li>
<li>在栈里面跳转到内存地址<img src="/2020/12/22/%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/0-3.png" alt="0-3"></li>
</ol>
<h3 id="一些操作快捷键"><a href="#一些操作快捷键" class="headerlink" title="一些操作快捷键"></a>一些操作快捷键</h3><p>F7（Step into）：单步执行，有CALL时进入函数</p>
<p>F8（Step Over）：单步执行，有CALL时不进入CALL的地址</p>
<p>Ctrl + G（Go to）：转到指定地址</p>
<p>F2：设置断点</p>
<p>F9：运行程序到断点处</p>
<h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><ol>
<li>不需要某条指令时，可以使用NOP设置为空指令。</li>
<li>栈窗口点击右键，选择addressing–&gt;relative to EBP,可以把地址调成相对于EBP</li>
</ol>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2020/12/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/">数据结构复习总结</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-12-22</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">期末复习</a></span><div class="content"><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>深度/高度:</strong>   最上面的是第一层【根节点】，最下面的是最后一层。</p>
<h2 id="树的存储结构表示【p105】"><a href="#树的存储结构表示【p105】" class="headerlink" title="树的存储结构表示【p105】"></a>树的存储结构表示【p105】</h2><h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><p>数组第一个单位内储存数据，第二个单位内储存该结点<strong>双亲结点</strong>的数组下标。</p>
<h3 id="孩子表示法【邻接表法】"><a href="#孩子表示法【邻接表法】" class="headerlink" title="孩子表示法【邻接表法】"></a>孩子表示法【邻接表法】</h3><p>数组第一个单位内储存数据，第二个单位内是一个后继指针，指向它的一个孩子结点，这个孩子结点又指向下一个孩子节点。【也可以增加一个单位来指向该结点的双亲结点】</p>
<h3 id="孩子兄弟表示法【二叉树表示法】"><a href="#孩子兄弟表示法【二叉树表示法】" class="headerlink" title="孩子兄弟表示法【二叉树表示法】"></a>孩子兄弟表示法【二叉树表示法】</h3><p>每个结点是一个结构体，包括data，firstchild，rightchild三个成员。</p>
<p>firstchild指向该节点的第一个孩子，rightchild指向该节点的下一个兄弟。</p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol>
<li><p>度为0的结点个数为n0，度为1的结点个数为n1，度为1的结点个数为n1。则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n0 &#x3D; n2 + 1     &#x2F;&#x2F;n&#x3D;n0+n1+n2;n&#x3D;side+1;side&#x3D;n1+2*n2;</span><br></pre></td></tr></table></figure>
</li>
<li><p>具有n个结点的完全二叉树的深度为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[lbn]+1</span><br></pre></td></tr></table></figure>
</li>
<li><p>对完全二叉树从根节点开始按顺序编号，如果某结点是i，其左孩子是2i，右孩子是2i+1</p>
</li>
</ol>
<h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><h4 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h4><p>空的位置数组元素为0，非空的里填数据。</p>
<p><strong>缺点：</strong>对于空元素比较多，比如单支树，会有很多内存浪费。</p>
<h4 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h4><p>每个结点设为一个结构体，设Lchild，Rchild，data，[parent]。</p>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>先序遍历：根-左子树-右子树</p>
<p>中序遍历：左子树-根-右子树</p>
<p>后序遍历：左子树-右子树-根</p>
<p>按层遍历：借助队列完成遍历</p>
<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p>每个结点是一个结构体，包含Lch，LTag，data，RTag，Rch。</p>
<p>结点有左子树，则指向左子树，否则指向前驱节点。结点有右子树，则指向右子树，否则指向后继结点。</p>
<p>对于如何连接线索二叉树的前驱和后继结点，只需先写好<strong>中序遍历顺序</strong>即可。</p>
<h2 id="树、森林、二叉树的转化"><a href="#树、森林、二叉树的转化" class="headerlink" title="树、森林、二叉树的转化"></a>树、森林、二叉树的转化</h2><h3 id="森林转化为二叉树"><a href="#森林转化为二叉树" class="headerlink" title="森林转化为二叉树"></a>森林转化为二叉树</h3><ol>
<li>把森林里的每一棵树转化为二叉树【除了与第一个孩子的连线全部删掉，将兄弟之间连好】</li>
<li>依次把右边二叉树的<strong>根节点</strong>作为左边二叉树<strong>根节点的右孩子</strong>。</li>
</ol>
<h3 id="二叉树转化为树"><a href="#二叉树转化为树" class="headerlink" title="二叉树转化为树"></a>二叉树转化为树</h3><ol>
<li>加线。如果某个结点有左孩子，则将该结点与该节点的左孩子的右孩子、右孩子的右孩子……连线。</li>
<li>去线。删除原二叉树里所有结点与其右孩子的连线。</li>
</ol>
<h3 id="二叉树转化为森林"><a href="#二叉树转化为森林" class="headerlink" title="二叉树转化为森林"></a>二叉树转化为森林</h3><p>先判断能不能转化为森林：【根节点有没有右孩子，有则可以】</p>
<ol>
<li>如果根节点有右孩子，删除与右孩子连线。接着判断该右孩子有没有右孩子，若有，重复上述操作。</li>
<li>将分开的几棵二叉树转化为树</li>
</ol>
<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>WPL = 所有叶子结点，每个叶子结点，用其权值*到其的线的个数。</p>
<h3 id="哈夫曼树的创建"><a href="#哈夫曼树的创建" class="headerlink" title="哈夫曼树的创建"></a>哈夫曼树的创建</h3><h3 id="哈夫曼树的编码"><a href="#哈夫曼树的编码" class="headerlink" title="哈夫曼树的编码"></a>哈夫曼树的编码</h3><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><ol>
<li>图常表示为G(V,E)，G表示一个图，V是图中顶点的集合，E是图中连线的集合。</li>
<li>如果两顶点之间的连线没有方向，则称这条连线为<strong>边</strong>。如果两顶点之间的连线有方向，则称这条连线为<strong>弧</strong>。箭头出发点叫<strong>弧尾</strong>，箭头指向的叫<strong>弧头</strong>。</li>
<li><strong>强连通图</strong>：对有向图中的任意两个顶点vi，vj，均有能从vi到vj和从vj到vi。</li>
</ol>
<h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><h3 id="邻接矩阵表示法"><a href="#邻接矩阵表示法" class="headerlink" title="邻接矩阵表示法"></a>邻接矩阵表示法</h3><h3 id="邻接表-逆连接表表示法"><a href="#邻接表-逆连接表表示法" class="headerlink" title="邻接表/逆连接表表示法"></a>邻接表/逆连接表表示法</h3><p>邻接表：获取出度容易，入度难。</p>
<p>逆邻接表：获取入度容易，出度难。</p>
<h3 id="十字链表表示法【p191】"><a href="#十字链表表示法【p191】" class="headerlink" title="十字链表表示法【p191】"></a>十字链表表示法【p191】</h3><p>（图）</p>
<p>十字链表的每一个结点代表一条弧。</p>
<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><ol>
<li>深度优先遍历【无法遍历时返回<strong>最接近</strong>的一个可继续遍历的结点继续遍历】</li>
<li>广度优先遍历</li>
</ol>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="普里姆【Prim】算法"><a href="#普里姆【Prim】算法" class="headerlink" title="普里姆【Prim】算法"></a>普里姆【Prim】算法</h3><p>假设未经历过的点为白色，经历过的点为灰色。</p>
<p>先将出发点变灰，查看由灰色的点出发所能到达的白色点中权值最小的一个，将那个白色点标灰。</p>
<p>依次类推，直到遍历完所有的点。</p>
<h3 id="克鲁斯卡尔【Kruskal】算法"><a href="#克鲁斯卡尔【Kruskal】算法" class="headerlink" title="克鲁斯卡尔【Kruskal】算法"></a>克鲁斯卡尔【Kruskal】算法</h3><p>从全图中找到权值最小的那些点，如果连上这些边不会形成回路，则连上这条边。</p>
<p>重复以上操作，直到遍历完所有的点。</p>
<h2 id="有向无环图及其应用"><a href="#有向无环图及其应用" class="headerlink" title="有向无环图及其应用"></a>有向无环图及其应用</h2><h3 id="关键路径的计算"><a href="#关键路径的计算" class="headerlink" title="关键路径的计算"></a>关键路径的计算</h3><p>过去求最早用max，回来求最晚用min</p>
<h3 id="最短路径的计算"><a href="#最短路径的计算" class="headerlink" title="最短路径的计算"></a>最短路径的计算</h3><h4 id="迪杰斯特拉【Dijkstra】算法"><a href="#迪杰斯特拉【Dijkstra】算法" class="headerlink" title="迪杰斯特拉【Dijkstra】算法"></a>迪杰斯特拉【Dijkstra】算法</h4><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>ASL（Average Search Length）=YASL+NASL</p>
<h2 id="几种表的查找"><a href="#几种表的查找" class="headerlink" title="几种表的查找"></a>几种表的查找</h2><h3 id="顺序表的查找"><a href="#顺序表的查找" class="headerlink" title="顺序表的查找"></a>顺序表的查找</h3><p>YASL=(n+1)/2</p>
<h3 id="有序表的查找"><a href="#有序表的查找" class="headerlink" title="有序表的查找"></a>有序表的查找</h3><p>折半查找：ASL=YASL+NASL=lb(n+1) + [lbn]</p>
<p><strong>折半查找的时间复杂度：O（lbn）</strong></p>
<blockquote>
<p>不一定折半，可以通过计算D=（K-data[low]）/（data[high]-data[low]）</p>
<p>来确定几分查找，其中K是查找的值</p>
</blockquote>
<h3 id="索引表的查找"><a href="#索引表的查找" class="headerlink" title="索引表的查找"></a>索引表的查找</h3><ol>
<li>稠密索引</li>
<li>分块索引：块内无序，块间有序</li>
</ol>
<p>最好的时间复杂度：O(  2^(1/2)  )，即块数和块内元素个数相等时</p>
<h2 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h2><p>概念：左子树的值小于根的值，右子树的值大于根的值。</p>
<h2 id="平衡二叉树【AVL树】"><a href="#平衡二叉树【AVL树】" class="headerlink" title="平衡二叉树【AVL树】"></a>平衡二叉树【AVL树】</h2><p>概念：首先是一个二叉排序树，其次每一个结点的<strong>（左子树高度-右子树高度）</strong>的值只能为-1,0,1这三个值。</p>
<p><strong>查找、插入、删除时间复杂度：O(lbn)</strong></p>
<h2 id="哈希查找"><a href="#哈希查找" class="headerlink" title="哈希查找"></a>哈希查找</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol>
<li>直接定址法</li>
<li>数字分析法</li>
<li>折叠法</li>
<li>除留取余法</li>
</ol>
<h3 id="处理冲突的方法"><a href="#处理冲突的方法" class="headerlink" title="处理冲突的方法"></a>处理冲突的方法</h3><h4 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h4><ol>
<li>线性探测</li>
<li>二次探测</li>
<li>随机探测</li>
</ol>
<h4 id="再哈希法"><a href="#再哈希法" class="headerlink" title="再哈希法"></a>再哈希法</h4><h4 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h4><h4 id="公共溢出法"><a href="#公共溢出法" class="headerlink" title="公共溢出法"></a>公共溢出法</h4><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>装填因子α=填入表的记录个数/哈希表长度</p>
<p>如果找到了好的装填因子，那么哈希查找的时间复杂度就是O(C)。</p>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h2 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h2><p><img src="/2020/12/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/1.jpg" alt="1"></p>
</div><hr></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-chevron-right&quot;&gt;&lt;&#x2F;i&gt;</a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://Albatross-G.github.io/img/a1.png)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2021 By George</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody" target="_blank" rel="noopener"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body></html>